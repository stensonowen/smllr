var data = {lines:[
{"lineNum":"    1","line":"//! Internals of the Cataloge data structure: identifying files by their size, hash, or first bytes"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"use std::collections::HashMap;"},
{"lineNum":"    4","line":"use std::path::{Path, PathBuf};"},
{"lineNum":"    5","line":"use std::collections::hash_map::Entry;"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"use vfs::{File, VFS};"},
{"lineNum":"    8","line":"use helpers::ID;"},
{"lineNum":"    9","line":"use hash::FileHash;"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// Duplicates is a decorator for a vector of pathbufs which represents"},
{"lineNum":"   12","line":"// a set of files. In code, it is an invariant that any 2 files in a"},
{"lineNum":"   13","line":"// duplicates are identicle."},
{"lineNum":"   14","line":"#[derive(Clone)]","class":"lineCov","hits":"3","order":"4730","possible_hits":"3",},
{"lineNum":"   15","line":"/// Collection of `PathBuf`s that point to identical files"},
{"lineNum":"   16","line":"pub struct Duplicates(pub(crate) Vec<PathBuf>);","class":"lineCov","hits":"1","order":"4731","possible_hits":"1",},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"impl Duplicates {"},
{"lineNum":"   19","line":"    // Convert a path to a vector of length 1 containing that path"},
{"lineNum":"   20","line":"    fn from(path: &Path) -> Self {","class":"linePartCov","hits":"2","order":"4711","possible_hits":"3",},
{"lineNum":"   21","line":"        Duplicates(vec![path.to_path_buf()])","class":"linePartCov","hits":"1","order":"4712","possible_hits":"2",},
{"lineNum":"   22","line":"    }","class":"lineCov","hits":"1","order":"4713","possible_hits":"1",},
{"lineNum":"   23","line":"    // Convert the first element to a path"},
{"lineNum":"   24","line":"    fn get_path(&self) -> &Path {","class":"lineCov","hits":"2","order":"4973","possible_hits":"2",},
{"lineNum":"   25","line":"        &self.0[0]","class":"lineCov","hits":"1","order":"4974","possible_hits":"1",},
{"lineNum":"   26","line":"    }","class":"linePartCov","hits":"1","order":"4975","possible_hits":"2",},
{"lineNum":"   27","line":"    // Add path to this Duplicates"},
{"lineNum":"   28","line":"    fn push(&mut self, path: &Path) {","class":"linePartCov","hits":"2","order":"5098","possible_hits":"3",},
{"lineNum":"   29","line":"        self.0.push(path.to_path_buf());","class":"lineCov","hits":"1","order":"5099","possible_hits":"1",},
{"lineNum":"   30","line":"    }","class":"lineCov","hits":"1","order":"5109","possible_hits":"1",},
{"lineNum":"   31","line":"    // Add all elements in another object othr to this Duplicates"},
{"lineNum":"   32","line":"    fn append(&mut self, mut othr: Duplicates) {","class":"linePartCov","hits":"2","order":"4999","possible_hits":"3",},
{"lineNum":"   33","line":"        self.0.append(&mut othr.0);","class":"lineCov","hits":"1","order":"5000","possible_hits":"1",},
{"lineNum":"   34","line":"    }","class":"linePartCov","hits":"1","order":"5015","possible_hits":"2",},
{"lineNum":"   35","line":"}"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"// Begin FirstKBytesProxy"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"/// Proxy of firstbytes: until two elements have been added, there is no"},
{"lineNum":"   40","line":"/// chance of a collision so put off constructing the hashmap and shortcut"},
{"lineNum":"   41","line":"pub enum FirstKBytesProxy<H: FileHash> {"},
{"lineNum":"   42","line":"    // in the first state there is one file"},
{"lineNum":"   43","line":"    // don\'t look up its first k bytes unless it has the same size as another"},
{"lineNum":"   44","line":"    Delay {"},
{"lineNum":"   45","line":"        /// The unique identifier of this collection"},
{"lineNum":"   46","line":"        id: ID,"},
{"lineNum":"   47","line":"        /// A collection of hard links"},
{"lineNum":"   48","line":"        dups: Duplicates,"},
{"lineNum":"   49","line":"    },"},
{"lineNum":"   50","line":"    // after 2 files with the first k bytes have been found, store them"},
{"lineNum":"   51","line":"    // also maintain a shortcut for looking up their values by their id"},
{"lineNum":"   52","line":"    // for hardlink detection."},
{"lineNum":"   53","line":"    Thunk {"},
{"lineNum":"   54","line":"        /// Identify a `HashProxy` by the hash of the first K bytes"},
{"lineNum":"   55","line":"        thunk: HashMap<<H as FileHash>::Output, HashProxy<H>>,"},
{"lineNum":"   56","line":"        /// Map the unique identifier to a first k bytes hash to enable registering links later"},
{"lineNum":"   57","line":"        shortcut: HashMap<ID, <H as FileHash>::Output>,"},
{"lineNum":"   58","line":"    },"},
{"lineNum":"   59","line":"}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"impl<H: FileHash> FirstKBytesProxy<H> {"},
{"lineNum":"   63","line":"    /// Construct a new FirstKBytesProxy with delay of path"},
{"lineNum":"   64","line":"    pub fn new(id: ID, path: &Path) -> Self {","class":"lineCov","hits":"4","order":"4708","possible_hits":"4",},
{"lineNum":"   65","line":"        FirstKBytesProxy::Delay {","class":"lineCov","hits":"2","order":"4714","possible_hits":"2",},
{"lineNum":"   66","line":"            id,","class":"lineCov","hits":"2","order":"4709","possible_hits":"2",},
{"lineNum":"   67","line":"            dups: Duplicates::from(path),","class":"lineCov","hits":"2","order":"4710","possible_hits":"2",},
{"lineNum":"   68","line":"        }"},
{"lineNum":"   69","line":"    }","class":"linePartCov","hits":"2","order":"4715","possible_hits":"4",},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    /// Traverse contained `HashProxy`s and identify contents with more than one"},
{"lineNum":"   72","line":"    /// path associated with it"},
{"lineNum":"   73","line":"    pub(super) fn get_repeats(&self) -> Vec<Duplicates> {","class":"linePartCov","hits":"4","order":"4920","possible_hits":"6",},
{"lineNum":"   74","line":"        match *self {","class":"linePartCov","hits":"3","order":"4949","possible_hits":"12",},
{"lineNum":"   75","line":"            // in the Delay state, return `dups` if it contains multiple paths"},
{"lineNum":"   76","line":"            FirstKBytesProxy::Delay { ref dups, .. } => if dups.0.len() >= 2 {","class":"linePartCov","hits":"6","order":"4921","possible_hits":"8",},
{"lineNum":"   77","line":"                vec![dups.clone()]","class":"linePartCov","hits":"2","order":"5111","possible_hits":"6",},
{"lineNum":"   78","line":"            } else {"},
{"lineNum":"   79","line":"                vec![]","class":"linePartCov","hits":"1","order":"5146","possible_hits":"2",},
{"lineNum":"   80","line":"            },"},
{"lineNum":"   81","line":"            // in the Thunk state, traverse all `HashProx`s"},
{"lineNum":"   82","line":"            FirstKBytesProxy::Thunk { ref thunk, .. } => {","class":"linePartCov","hits":"1","order":"4922","possible_hits":"2",},
{"lineNum":"   83","line":"                thunk.iter().fold(vec![], |mut acc, (_fb, hp)| {","class":"linePartCov","hits":"5","order":"4923","possible_hits":"12",},
{"lineNum":"   84","line":"                    acc.append(&mut hp.get_repeats());","class":"linePartCov","hits":"1","order":"4924","possible_hits":"4",},
{"lineNum":"   85","line":"                    acc","class":"linePartCov","hits":"1","order":"4947","possible_hits":"2",},
{"lineNum":"   86","line":"                })","class":"linePartCov","hits":"1","order":"4948","possible_hits":"4",},
{"lineNum":"   87","line":"            }"},
{"lineNum":"   88","line":"        }"},
{"lineNum":"   89","line":"    }","class":"lineCov","hits":"2","order":"4950","possible_hits":"2",},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"    /// Transition type from a Delay to a Thunk with the introduction of a new file"},
{"lineNum":"   92","line":"    /// Preview both files and add them to the contents of the new Thunk"},
{"lineNum":"   93","line":"    fn transition<T: VFS>(&mut self, vfs: &T, new_id: ID, new_path: &Path) {","class":"linePartCov","hits":"2","order":"4727","possible_hits":"6",},
{"lineNum":"   94","line":"        // convert from a Delay to a Thunk"},
{"lineNum":"   95","line":"        // panics if new belongs in Delay.dups"},
{"lineNum":"   96","line":"        // panics if `self` is of type Thunk"},
{"lineNum":"   97","line":"        // NOTE this involves EITHER a clone of dups OR a promise-violating hack"},
{"lineNum":"   98","line":"        let (del_id, del_dups) = match *self {","class":"linePartCov","hits":"1","order":"4747","possible_hits":"2",},
{"lineNum":"   99","line":"            FirstKBytesProxy::Delay { id, ref mut dups } => {","class":"linePartCov","hits":"2","order":"4728","possible_hits":"4",},
{"lineNum":"  100","line":"                // this a somewhat hacky potential future speedup"},
{"lineNum":"  101","line":"                // if there are problems with Duplicates being empty, look here"},
{"lineNum":"  102","line":"                // \"steal\" `dups` so we don\'t have to clone it"},
{"lineNum":"  103","line":"                // but we can\'t just take it because we can\'t consume self"},
{"lineNum":"  104","line":"                // OPTION A: the possibly dangerous but more efficient one:"},
{"lineNum":"  105","line":"                //let stolen_dups = ::std::mem::replace(dups, Duplicates(vec![]));"},
{"lineNum":"  106","line":"                //(id, stolen_dups)"},
{"lineNum":"  107","line":"                // OPTION B: the safer but more expensive version:"},
{"lineNum":"  108","line":"                (id, dups.clone())","class":"linePartCov","hits":"1","order":"4729","possible_hits":"2",},
{"lineNum":"  109","line":"            }"},
{"lineNum":"  110","line":"            _ => unreachable!(),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  111","line":"        };"},
{"lineNum":"  112","line":"        assert!(new_id != del_id);","class":"linePartCov","hits":"2","order":"4748","possible_hits":"6",},
{"lineNum":"  113","line":"        // Initialize new type\'s variables"},
{"lineNum":"  114","line":"        let mut thunk: HashMap<<H as FileHash>::Output, _> = HashMap::new();","class":"linePartCov","hits":"1","order":"4749","possible_hits":"2",},
{"lineNum":"  115","line":"        let mut shortcut: HashMap<_, <H as FileHash>::Output> = HashMap::new();","class":"linePartCov","hits":"1","order":"4750","possible_hits":"2",},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"        // get first bytes of both files"},
{"lineNum":"  118","line":"        let new_file = vfs.get_file(new_path)","class":"linePartCov","hits":"1","order":"4751","possible_hits":"4",},
{"lineNum":"  119","line":"            .expect(\"Failed to get file from path\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  120","line":"        let old_file = vfs.get_file(&del_dups.0[0])","class":"linePartCov","hits":"2","order":"4752","possible_hits":"6",},
{"lineNum":"  121","line":"            .expect(\"Failed to get file from path\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  122","line":"        let new_first_bytes: <H as FileHash>::Output = new_file","class":"linePartCov","hits":"2","order":"4755","possible_hits":"6",},
{"lineNum":"  123","line":"            .get_first_bytes::<H>()"},
{"lineNum":"  124","line":"            .expect(\"Failed to hash first bytes\");","class":"linePartCov","hits":"1","order":"4866","possible_hits":"4",},
{"lineNum":"  125","line":"        let old_first_bytes: <H as FileHash>::Output = old_file","class":"linePartCov","hits":"2","order":"4867","possible_hits":"6",},
{"lineNum":"  126","line":"            .get_first_bytes::<H>()"},
{"lineNum":"  127","line":"            .expect(\"Failed to hash first bytes\");","class":"linePartCov","hits":"1","order":"4868","possible_hits":"4",},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"        // and add them to the map\'s shortcut."},
{"lineNum":"  130","line":"        shortcut.insert(new_id, new_first_bytes.clone());","class":"linePartCov","hits":"2","order":"4869","possible_hits":"6",},
{"lineNum":"  131","line":"        shortcut.insert(del_id, old_first_bytes.clone());","class":"linePartCov","hits":"1","order":"4870","possible_hits":"2",},
{"lineNum":"  132","line":"        // construct duplicate wraper around the new path and insert into new"},
{"lineNum":"  133","line":"        // hashmap."},
{"lineNum":"  134","line":"        let new_dups = Duplicates::from(new_path);","class":"linePartCov","hits":"1","order":"4871","possible_hits":"4",},
{"lineNum":"  135","line":"        if new_first_bytes == old_first_bytes {","class":"linePartCov","hits":"4","order":"4872","possible_hits":"10",},
{"lineNum":"  136","line":"            let mut hp = HashProxy::new(del_id, del_dups);","class":"linePartCov","hits":"2","order":"4957","possible_hits":"4",},
{"lineNum":"  137","line":"            hp.insert(vfs, new_id, new_dups);","class":"linePartCov","hits":"1","order":"4958","possible_hits":"4",},
{"lineNum":"  138","line":"            thunk.insert(old_first_bytes, hp);","class":"linePartCov","hits":"2","order":"5019","possible_hits":"4",},
{"lineNum":"  139","line":"        } else {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  140","line":"            thunk.insert(new_first_bytes, HashProxy::new(new_id, new_dups));","class":"linePartCov","hits":"1","order":"4883","possible_hits":"6",},
{"lineNum":"  141","line":"            thunk.insert(old_first_bytes, HashProxy::new(del_id, del_dups));","class":"linePartCov","hits":"1","order":"4890","possible_hits":"4",},
{"lineNum":"  142","line":"        }"},
{"lineNum":"  143","line":"        // replace pointer from delay a pointer to thunk."},
{"lineNum":"  144","line":"        *self = FirstKBytesProxy::Thunk { thunk, shortcut };","class":"linePartCov","hits":"1","order":"4891","possible_hits":"4",},
{"lineNum":"  145","line":"    }","class":"linePartCov","hits":"2","order":"4892","possible_hits":"18",},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"    /// Add a new path to the proxy"},
{"lineNum":"  148","line":"    pub fn insert<T: VFS>(&mut self, vfs: &T, id: ID, path: &Path) {","class":"linePartCov","hits":"2","order":"4718","possible_hits":"6",},
{"lineNum":"  149","line":"        match *self {","class":"linePartCov","hits":"3","order":"4893","possible_hits":"12",},
{"lineNum":"  150","line":"            // If a hard link and self is a Delay, insert a hard link to what\'s"},
{"lineNum":"  151","line":"            // already stored in Delay"},
{"lineNum":"  152","line":"            FirstKBytesProxy::Delay {","class":"linePartCov","hits":"1","order":"4719","possible_hits":"2",},
{"lineNum":"  153","line":"                id: id2,","class":"linePartCov","hits":"1","order":"4720","possible_hits":"2",},
{"lineNum":"  154","line":"                ref mut dups,","class":"linePartCov","hits":"1","order":"4721","possible_hits":"2",},
{"lineNum":"  155","line":"                .."},
{"lineNum":"  156","line":"            } if id == id2 =>","class":"linePartCov","hits":"2","order":"4722","possible_hits":"4",},
{"lineNum":"  157","line":"            {"},
{"lineNum":"  158","line":"                dups.push(path);","class":"linePartCov","hits":"1","order":"5097","possible_hits":"2",},
{"lineNum":"  159","line":"            }"},
{"lineNum":"  160","line":"            // If self is a thunk get first bytes and add to shortcut."},
{"lineNum":"  161","line":"            // If a match for a proxy, add"},
{"lineNum":"  162","line":"            // to the proxy; otherwise create a new hashproxy."},
{"lineNum":"  163","line":"            FirstKBytesProxy::Thunk {"},
{"lineNum":"  164","line":"                ref mut thunk,","class":"linePartCov","hits":"1","order":"4895","possible_hits":"2",},
{"lineNum":"  165","line":"                ref mut shortcut,","class":"linePartCov","hits":"1","order":"4896","possible_hits":"2",},
{"lineNum":"  166","line":"            } => {"},
{"lineNum":"  167","line":"                let file = vfs.get_file(path).expect(\"Failed to get file\");","class":"linePartCov","hits":"2","order":"4897","possible_hits":"4",},
{"lineNum":"  168","line":"                let first_bytes: <H as FileHash>::Output = file.get_first_bytes::<H>()","class":"linePartCov","hits":"2","order":"4898","possible_hits":"6",},
{"lineNum":"  169","line":"                    .expect(\"Failed to hash first bytes\");","class":"linePartCov","hits":"1","order":"4899","possible_hits":"4",},
{"lineNum":"  170","line":"                shortcut.insert(id, first_bytes.clone());","class":"linePartCov","hits":"2","order":"4900","possible_hits":"6",},
{"lineNum":"  171","line":"                match thunk.entry(first_bytes) {","class":"linePartCov","hits":"1","order":"4901","possible_hits":"12",},
{"lineNum":"  172","line":"                    // call `insert` on the underlying HashProxy"},
{"lineNum":"  173","line":"                    Entry::Occupied(mut occ_entry) => {","class":"linePartCov","hits":"2","order":"4902","possible_hits":"4",},
{"lineNum":"  174","line":"                        occ_entry.get_mut().insert(vfs, id, Duplicates::from(path))","class":"linePartCov","hits":"3","order":"5020","possible_hits":"6",},
{"lineNum":"  175","line":"                    }"},
{"lineNum":"  176","line":"                    // not there: create a new HashProxy"},
{"lineNum":"  177","line":"                    Entry::Vacant(vac_entry) => {","class":"linePartCov","hits":"1","order":"4903","possible_hits":"2",},
{"lineNum":"  178","line":"                        let hp = HashProxy::new(id, Duplicates::from(path));","class":"linePartCov","hits":"2","order":"4904","possible_hits":"4",},
{"lineNum":"  179","line":"                        vac_entry.insert(hp);","class":"linePartCov","hits":"1","order":"4905","possible_hits":"2",},
{"lineNum":"  180","line":"                    }"},
{"lineNum":"  181","line":"                }","class":"linePartCov","hits":"1","order":"4906","possible_hits":"6",},
{"lineNum":"  182","line":"            }","class":"linePartCov","hits":"2","order":"4907","possible_hits":"14",},
{"lineNum":"  183","line":"            // If we are a delay and need to insert a path that is not a hardlink,"},
{"lineNum":"  184","line":"            // transition to a thunk"},
{"lineNum":"  185","line":"            FirstKBytesProxy::Delay { .. } => self.transition(vfs, id, path),","class":"linePartCov","hits":"1","order":"4726","possible_hits":"2",},
{"lineNum":"  186","line":"        }"},
{"lineNum":"  187","line":"    }","class":"linePartCov","hits":"1","order":"4894","possible_hits":"2",},
{"lineNum":"  188","line":"}"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"// Begin HashProxy"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"/// Proxy of hashes: until two elements have been added, there is no"},
{"lineNum":"  193","line":"/// chance of a collision so put off constructing the hashmap and shortcut"},
{"lineNum":"  194","line":"pub enum HashProxy<H: FileHash> {"},
{"lineNum":"  195","line":"    // only one unique element has been added"},
{"lineNum":"  196","line":"    Delay {"},
{"lineNum":"  197","line":"        /// The unique identifier for the paths"},
{"lineNum":"  198","line":"        id: ID,"},
{"lineNum":"  199","line":"        /// A collection of duplicate paths"},
{"lineNum":"  200","line":"        dups: Duplicates,"},
{"lineNum":"  201","line":"    },"},
{"lineNum":"  202","line":"    // need to map `Hash`es to a set of `Duplicates`"},
{"lineNum":"  203","line":"    Thunk {"},
{"lineNum":"  204","line":"        /// Identify a set of duplicates by the hash of its complete contents"},
{"lineNum":"  205","line":"        thunk: HashMap<<H as FileHash>::Output, Duplicates>,"},
{"lineNum":"  206","line":"        /// Map the unique identifier to a file\'s hash to enable registering links later"},
{"lineNum":"  207","line":"        shortcut: HashMap<ID, <H as FileHash>::Output>,"},
{"lineNum":"  208","line":"    },"},
{"lineNum":"  209","line":"    // see `FirstKBytesProxy` for more documentation"},
{"lineNum":"  210","line":"    // major difference is that `Duplicates` can contain non-hardlinks"},
{"lineNum":"  211","line":"}"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"// closely parallels FirstKBytesProxy\'s documentation"},
{"lineNum":"  215","line":"impl<H: FileHash> HashProxy<H> {"},
{"lineNum":"  216","line":"    //Construct a new hashprxy. As only 1 object, will be of the Delay type."},
{"lineNum":"  217","line":"    fn new(id: ID, dups: Duplicates) -> Self {","class":"linePartCov","hits":"2","order":"4884","possible_hits":"4",},
{"lineNum":"  218","line":"        HashProxy::Delay { id, dups }","class":"linePartCov","hits":"1","order":"4885","possible_hits":"2",},
{"lineNum":"  219","line":"    }","class":"linePartCov","hits":"1","order":"4886","possible_hits":"4",},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"    // get all repeats under this node and return as a set of sets of duplicates."},
{"lineNum":"  222","line":"    /// Check all Duplicates for files associated with multiple Paths"},
{"lineNum":"  223","line":"    fn get_repeats(&self) -> Vec<Duplicates> {","class":"linePartCov","hits":"2","order":"4925","possible_hits":"6",},
{"lineNum":"  224","line":"        match *self {","class":"linePartCov","hits":"2","order":"4928","possible_hits":"10",},
{"lineNum":"  225","line":"            HashProxy::Delay { ref dups, .. } => if dups.0.len() >= 2 {","class":"linePartCov","hits":"3","order":"4926","possible_hits":"8",},
{"lineNum":"  226","line":"                vec![dups.clone()]","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  227","line":"            } else {"},
{"lineNum":"  228","line":"                vec![]","class":"linePartCov","hits":"1","order":"4927","possible_hits":"2",},
{"lineNum":"  229","line":"            },"},
{"lineNum":"  230","line":"            HashProxy::Thunk { ref thunk, .. } => {","class":"linePartCov","hits":"1","order":"5034","possible_hits":"2",},
{"lineNum":"  231","line":"                thunk","class":"linePartCov","hits":"2","order":"5035","possible_hits":"4",},
{"lineNum":"  232","line":"                    .iter()"},
{"lineNum":"  233","line":"                    .filter_map(|(_hash, repeats)| {","class":"linePartCov","hits":"2","order":"5041","possible_hits":"4",},
{"lineNum":"  234","line":"                        if repeats.0.len() >= 2 {","class":"linePartCov","hits":"2","order":"5042","possible_hits":"4",},
{"lineNum":"  235","line":"                            // if there are 2 or more elements"},
{"lineNum":"  236","line":"                            // (including 2 links to 1 file)"},
{"lineNum":"  237","line":"                            Some(repeats.clone())","class":"linePartCov","hits":"2","order":"5043","possible_hits":"4",},
{"lineNum":"  238","line":"                        } else {"},
{"lineNum":"  239","line":"                            // exactly one representation on the hard drive"},
{"lineNum":"  240","line":"                            None","class":"linePartCov","hits":"1","order":"5182","possible_hits":"2",},
{"lineNum":"  241","line":"                        }"},
{"lineNum":"  242","line":"                    })","class":"linePartCov","hits":"1","order":"5044","possible_hits":"4",},
{"lineNum":"  243","line":"                    .collect()"},
{"lineNum":"  244","line":"            }"},
{"lineNum":"  245","line":"        }"},
{"lineNum":"  246","line":"    }","class":"linePartCov","hits":"1","order":"4929","possible_hits":"2",},
{"lineNum":"  247","line":"    // private helper fuction which handles the conversion from Delay to HashProxy::Thunk"},
{"lineNum":"  248","line":"    fn transition<T: VFS>(&mut self, vfs: &T, new_id: ID, new_dups: Duplicates) {","class":"linePartCov","hits":"2","order":"4965","possible_hits":"6",},
{"lineNum":"  249","line":"        // convert Delay to Thunk"},
{"lineNum":"  250","line":"        let (del_id, del_dups) = match *self {","class":"linePartCov","hits":"1","order":"4969","possible_hits":"8",},
{"lineNum":"  251","line":"            HashProxy::Delay { id, ref mut dups } => {","class":"linePartCov","hits":"2","order":"4966","possible_hits":"4",},
{"lineNum":"  252","line":"                assert!(id != new_id);","class":"linePartCov","hits":"1","order":"4967","possible_hits":"4",},
{"lineNum":"  253","line":"                (id, dups.clone())","class":"linePartCov","hits":"2","order":"4968","possible_hits":"4",},
{"lineNum":"  254","line":"            }"},
{"lineNum":"  255","line":"            _ => unreachable!(),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  256","line":"        };"},
{"lineNum":"  257","line":"        //Set up variables for thunk state"},
{"lineNum":"  258","line":"        let mut thunk: HashMap<<H as FileHash>::Output, Duplicates> = HashMap::new();","class":"linePartCov","hits":"1","order":"4970","possible_hits":"2",},
{"lineNum":"  259","line":"        let mut shortcut = HashMap::new();","class":"linePartCov","hits":"1","order":"4971","possible_hits":"2",},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"        // get hashes"},
{"lineNum":"  262","line":"        let new_file = vfs.get_file(new_dups.get_path())","class":"linePartCov","hits":"1","order":"4972","possible_hits":"4",},
{"lineNum":"  263","line":"            .expect(\"Failed to get file\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  264","line":"        let old_file = vfs.get_file(del_dups.get_path())","class":"linePartCov","hits":"2","order":"4976","possible_hits":"6",},
{"lineNum":"  265","line":"            .expect(\"Failed to get file\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  266","line":"        let new_hash: <H as FileHash>::Output ="},
{"lineNum":"  267","line":"            new_file.get_hash::<H>().expect(\"Failed to hash file\");","class":"linePartCov","hits":"2","order":"4977","possible_hits":"8",},
{"lineNum":"  268","line":"        let old_hash: <H as FileHash>::Output ="},
{"lineNum":"  269","line":"            old_file.get_hash::<H>().expect(\"Failed to hash file\");","class":"linePartCov","hits":"2","order":"4985","possible_hits":"8",},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"        // insert into shortcut"},
{"lineNum":"  272","line":"        shortcut.insert(new_id, new_hash.clone());","class":"linePartCov","hits":"2","order":"4986","possible_hits":"6",},
{"lineNum":"  273","line":"        shortcut.insert(del_id, old_hash.clone());","class":"linePartCov","hits":"1","order":"4987","possible_hits":"2",},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"        // thunk: HashMap < Hash, Duplicates >"},
{"lineNum":"  276","line":"        thunk.insert(new_hash, new_dups);","class":"linePartCov","hits":"1","order":"4988","possible_hits":"2",},
{"lineNum":"  277","line":"        thunk","class":"linePartCov","hits":"2","order":"4990","possible_hits":"4",},
{"lineNum":"  278","line":"            .entry(old_hash)","class":"linePartCov","hits":"1","order":"4989","possible_hits":"2",},
{"lineNum":"  279","line":"            .or_insert_with(|| Duplicates(vec![]))","class":"linePartCov","hits":"2","order":"5176","possible_hits":"6",},
{"lineNum":"  280","line":"            .append(del_dups);","class":"linePartCov","hits":"1","order":"4998","possible_hits":"4",},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"        // set our pointer to the new thunk state."},
{"lineNum":"  283","line":"        *self = HashProxy::Thunk { thunk, shortcut };","class":"linePartCov","hits":"1","order":"5016","possible_hits":"4",},
{"lineNum":"  284","line":"    }","class":"linePartCov","hits":"2","order":"5017","possible_hits":"18",},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"    // insert Duplicate into the data structure"},
{"lineNum":"  287","line":"    fn insert<T: VFS>(&mut self, vfs: &T, id: ID, dups: Duplicates) {","class":"linePartCov","hits":"2","order":"4959","possible_hits":"6",},
{"lineNum":"  288","line":"        match *self {","class":"linePartCov","hits":"1","order":"5032","possible_hits":"18",},
{"lineNum":"  289","line":"            // if its just a hard link and we are in Delay: just append it"},
{"lineNum":"  290","line":"            HashProxy::Delay {","class":"linePartCov","hits":"1","order":"4960","possible_hits":"2",},
{"lineNum":"  291","line":"                id: id2,","class":"linePartCov","hits":"1","order":"4961","possible_hits":"2",},
{"lineNum":"  292","line":"                dups: ref mut dups2,","class":"linePartCov","hits":"1","order":"4962","possible_hits":"2",},
{"lineNum":"  293","line":"            } if id == id2 =>","class":"linePartCov","hits":"2","order":"4963","possible_hits":"4",},
{"lineNum":"  294","line":"            {"},
{"lineNum":"  295","line":"                dups2.append(dups);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  296","line":"            }"},
{"lineNum":"  297","line":"            // If we are in a thunk state, just add file and its hash"},
{"lineNum":"  298","line":"            HashProxy::Thunk {"},
{"lineNum":"  299","line":"                ref mut thunk,","class":"linePartCov","hits":"1","order":"5021","possible_hits":"2",},
{"lineNum":"  300","line":"                ref mut shortcut,","class":"linePartCov","hits":"1","order":"5022","possible_hits":"2",},
{"lineNum":"  301","line":"            } => {"},
{"lineNum":"  302","line":"                let file = vfs.get_file(dups.get_path())","class":"linePartCov","hits":"3","order":"5023","possible_hits":"6",},
{"lineNum":"  303","line":"                    .expect(\"Failed to get file from path\");"},
{"lineNum":"  304","line":"                let hash: <H as FileHash>::Output ="},
{"lineNum":"  305","line":"                    file.get_hash::<H>().expect(\"Failed to hash file\");","class":"linePartCov","hits":"2","order":"5024","possible_hits":"8",},
{"lineNum":"  306","line":"                shortcut.insert(id, hash.clone());","class":"linePartCov","hits":"2","order":"5025","possible_hits":"6",},
{"lineNum":"  307","line":"                match thunk.entry(hash) {","class":"linePartCov","hits":"1","order":"5026","possible_hits":"6",},
{"lineNum":"  308","line":"                    Entry::Occupied(mut occ_entry) => {","class":"linePartCov","hits":"2","order":"5027","possible_hits":"4",},
{"lineNum":"  309","line":"                        // if files are completely identical"},
{"lineNum":"  310","line":"                        // add to the repeat hashtable (the val of the thunk)"},
{"lineNum":"  311","line":"                        // either create it or append to its ID\'s existing entry"},
{"lineNum":"  312","line":"                        let repeats = occ_entry.get_mut();","class":"linePartCov","hits":"2","order":"5028","possible_hits":"4",},
{"lineNum":"  313","line":"                        repeats.append(dups);","class":"linePartCov","hits":"1","order":"5029","possible_hits":"2",},
{"lineNum":"  314","line":"                    } //  Otherwise just add it to a new hashmap."},
{"lineNum":"  315","line":"                    Entry::Vacant(vacant_entry) => {","class":"linePartCov","hits":"1","order":"5177","possible_hits":"2",},
{"lineNum":"  316","line":"                        vacant_entry.insert(dups);","class":"linePartCov","hits":"1","order":"5180","possible_hits":"2",},
{"lineNum":"  317","line":"                    }"},
{"lineNum":"  318","line":"                }","class":"linePartCov","hits":"1","order":"5030","possible_hits":"6",},
{"lineNum":"  319","line":"            }","class":"linePartCov","hits":"2","order":"5031","possible_hits":"14",},
{"lineNum":"  320","line":"            // if a new non-link file is added while self is a delay stage: transition to Thunk"},
{"lineNum":"  321","line":"            HashProxy::Delay { .. } => {"},
{"lineNum":"  322","line":"                self.transition(vfs, id, dups);","class":"linePartCov","hits":"1","order":"4964","possible_hits":"2",},
{"lineNum":"  323","line":"            }"},
{"lineNum":"  324","line":"        }"},
{"lineNum":"  325","line":"    }","class":"linePartCov","hits":"1","order":"5018","possible_hits":"6",},
{"lineNum":"  326","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "smllr-cd1387de2be9f35d", "date" : "2017-12-06 19:01:08", "instrumented" : 142, "covered" : 133,};
var merged_data = [];
