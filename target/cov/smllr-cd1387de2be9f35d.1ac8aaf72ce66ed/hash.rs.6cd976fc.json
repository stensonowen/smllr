var data = {lines:[
{"lineNum":"    1","line":"//! Hash files (in whole or in part) generically so user can determine algorithm at runtime"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"use md5;"},
{"lineNum":"    4","line":"use tiny_keccak;"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"use std::fmt::Debug;"},
{"lineNum":"    7","line":"use std::hash;"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"// The standard library has a similar trait: std::hash::Hash"},
{"lineNum":"   10","line":"// However, Rust does not allow you to implement a trait from an external crate"},
{"lineNum":"   11","line":"//  on an object in an external crate; one of them must be your own"},
{"lineNum":"   12","line":"// So to implement this we use our own FileHash trait"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"/// Easy way to hash byte arrays"},
{"lineNum":"   15","line":"pub trait FileHash: Debug {"},
{"lineNum":"   16","line":"    // Output must be Debug for the whole type to be"},
{"lineNum":"   17","line":"    // must be Eq and Hash to be a key for a hash table"},
{"lineNum":"   18","line":"    // must be Clone because hashes sometimes must be stored redundantly"},
{"lineNum":"   19","line":"    /// Output type of hashing (different algorithms returns differently sized outputs)"},
{"lineNum":"   20","line":"    type Output: Debug + Clone + Eq + hash::Hash; //+ ::std::ops::Index<usize>;"},
{"lineNum":"   21","line":"    /// Hash an array of bytes and return the result"},
{"lineNum":"   22","line":"    fn hash(bytes: &[u8]) -> Self::Output;"},
{"lineNum":"   23","line":"}"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/// Generate 128-bit MD5 digest"},
{"lineNum":"   26","line":"#[derive(Debug)]"},
{"lineNum":"   27","line":"pub struct Md5Sum;"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"/// Generate 256-bit Sha3 digest"},
{"lineNum":"   30","line":"#[derive(Debug)]"},
{"lineNum":"   31","line":"pub struct Sha3Sum;"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"// Md5Sum implementation wraps around `md5` crate"},
{"lineNum":"   34","line":"// returns a 128-bit hash"},
{"lineNum":"   35","line":"impl FileHash for Md5Sum {"},
{"lineNum":"   36","line":"    type Output = [u8; 16];"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"    fn hash(bytes: &[u8]) -> Self::Output {","class":"lineCov","hits":"2","order":"4821","possible_hits":"2",},
{"lineNum":"   39","line":"        *md5::compute(bytes)","class":"lineCov","hits":"1","order":"4822","possible_hits":"1",},
{"lineNum":"   40","line":"    }","class":"linePartCov","hits":"1","order":"4864","possible_hits":"2",},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"// Sha3Sum implementation wraps around `tiny_keccak` crate"},
{"lineNum":"   44","line":"// returns a 256-bit hash"},
{"lineNum":"   45","line":"impl FileHash for Sha3Sum {"},
{"lineNum":"   46","line":"    type Output = [u8; 32];"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"    fn hash(bytes: &[u8]) -> Self::Output {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   49","line":"        let mut sha = tiny_keccak::Keccak::new_sha3_256();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   50","line":"        let mut arr = [0u8; 32];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   51","line":"        sha.update(bytes);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   52","line":"        sha.finalize(&mut arr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   53","line":"        arr","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   54","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   55","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "smllr-cd1387de2be9f35d", "date" : "2017-12-06 19:01:08", "instrumented" : 10, "covered" : 3,};
var merged_data = [];
