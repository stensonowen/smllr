var data = {lines:[
{"lineNum":"    1","line":"use std::collections::HashMap;"},
{"lineNum":"    2","line":"use std::path::{Path, PathBuf};"},
{"lineNum":"    3","line":"use std::collections::hash_map::Entry;"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"use vfs::{File, VFS};"},
{"lineNum":"    6","line":"use super::ID;"},
{"lineNum":"    7","line":"use super::super::{FirstBytes, Hash};"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"// Duplicates is a decorator for a vector of pathbufs which represents"},
{"lineNum":"   10","line":"// a set of files. In code, it is an invariant that any 2 files in a"},
{"lineNum":"   11","line":"// duplicates are identicle."},
{"lineNum":"   12","line":"#[derive(Clone)]","class":"lineCov","hits":"3","order":"4666","possible_hits":"3",},
{"lineNum":"   13","line":"/// Collection of `PathBuf`s that point to identical files"},
{"lineNum":"   14","line":"pub struct Duplicates(pub(crate) Vec<PathBuf>);","class":"lineCov","hits":"1","order":"4667","possible_hits":"1",},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"impl Duplicates {"},
{"lineNum":"   17","line":"    // Convert a path to a vector of length 1 containing that path"},
{"lineNum":"   18","line":"    fn from(path: &Path) -> Self {","class":"linePartCov","hits":"2","order":"4647","possible_hits":"3",},
{"lineNum":"   19","line":"        Duplicates(vec![path.to_path_buf()])","class":"linePartCov","hits":"1","order":"4648","possible_hits":"2",},
{"lineNum":"   20","line":"    }","class":"lineCov","hits":"1","order":"4649","possible_hits":"1",},
{"lineNum":"   21","line":"    // Convert the first element to a path"},
{"lineNum":"   22","line":"    fn get_path(&self) -> &Path {","class":"lineCov","hits":"2","order":"4871","possible_hits":"2",},
{"lineNum":"   23","line":"        &self.0[0]","class":"lineCov","hits":"1","order":"4872","possible_hits":"1",},
{"lineNum":"   24","line":"    }","class":"linePartCov","hits":"1","order":"4873","possible_hits":"2",},
{"lineNum":"   25","line":"    // Add path to this Duplicates"},
{"lineNum":"   26","line":"    fn push(&mut self, path: &Path) {","class":"linePartCov","hits":"2","order":"5068","possible_hits":"3",},
{"lineNum":"   27","line":"        self.0.push(path.to_path_buf());","class":"lineCov","hits":"1","order":"5069","possible_hits":"1",},
{"lineNum":"   28","line":"    }","class":"lineCov","hits":"1","order":"5079","possible_hits":"1",},
{"lineNum":"   29","line":"    // Add all elements in another object othr to this Duplicates"},
{"lineNum":"   30","line":"    fn append(&mut self, mut othr: Duplicates) {","class":"linePartCov","hits":"2","order":"4947","possible_hits":"3",},
{"lineNum":"   31","line":"        self.0.append(&mut othr.0);","class":"lineCov","hits":"1","order":"4948","possible_hits":"1",},
{"lineNum":"   32","line":"    }","class":"linePartCov","hits":"1","order":"4977","possible_hits":"2",},
{"lineNum":"   33","line":"}"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"// Begin FirstKBytesProxy"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"/// Proxy of firstbytes: until two elements have been added, there is no"},
{"lineNum":"   38","line":"/// chance of a collision so put off constructing the hashmap and shortcut"},
{"lineNum":"   39","line":"pub enum FirstKBytesProxy {"},
{"lineNum":"   40","line":"    // in the first state there is one file"},
{"lineNum":"   41","line":"    // don\'t look up its first k bytes unless it has the same size as another"},
{"lineNum":"   42","line":"    Delay {"},
{"lineNum":"   43","line":"        id: ID,"},
{"lineNum":"   44","line":"        dups: Duplicates,"},
{"lineNum":"   45","line":"    },"},
{"lineNum":"   46","line":"    // after 2 files with the first k bytes have been found, store them"},
{"lineNum":"   47","line":"    // also maintain a shortcut for looking up their values by their id"},
{"lineNum":"   48","line":"    // for hardlink detection."},
{"lineNum":"   49","line":"    Thunk {"},
{"lineNum":"   50","line":"        thunk: HashMap<FirstBytes, HashProxy>,"},
{"lineNum":"   51","line":"        shortcut: HashMap<ID, FirstBytes>,"},
{"lineNum":"   52","line":"    },"},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"","class":"lineCov","hits":"2","order":"4644","possible_hits":"2",},
{"lineNum":"   56","line":"impl FirstKBytesProxy {","class":"lineCov","hits":"1","order":"4650","possible_hits":"1",},
{"lineNum":"   57","line":"    /// Construct a new FirstKBytesProxy with delay of path","class":"lineCov","hits":"1","order":"4645","possible_hits":"1",},
{"lineNum":"   58","line":"    pub fn new(id: ID, path: &Path) -> Self {","class":"lineCov","hits":"1","order":"4646","possible_hits":"1",},
{"lineNum":"   59","line":"        FirstKBytesProxy::Delay {"},
{"lineNum":"   60","line":"            id,","class":"linePartCov","hits":"1","order":"4651","possible_hits":"2",},
{"lineNum":"   61","line":"            dups: Duplicates::from(path),"},
{"lineNum":"   62","line":"        }"},
{"lineNum":"   63","line":"    }"},
{"lineNum":"   64","line":"","class":"linePartCov","hits":"2","order":"4809","possible_hits":"3",},
{"lineNum":"   65","line":"    /// Traverse contained `HashProxy`s and identify contents with more than one","class":"linePartCov","hits":"2","order":"4839","possible_hits":"6",},
{"lineNum":"   66","line":"    /// path associated with it"},
{"lineNum":"   67","line":"    pub(super) fn get_repeats(&self) -> Vec<Duplicates> {","class":"lineCov","hits":"1","order":"4810","possible_hits":"1",},
{"lineNum":"   68","line":"        match *self {","class":"lineCov","hits":"4","order":"5081","possible_hits":"4",},
{"lineNum":"   69","line":"            // in the Delay state, return `dups` if it contains multiple paths","class":"linePartCov","hits":"2","order":"5082","possible_hits":"3",},
{"lineNum":"   70","line":"            FirstKBytesProxy::Delay { ref dups, .. } => if dups.0.len() >= 2 {"},
{"lineNum":"   71","line":"                vec![dups.clone()]","class":"lineCov","hits":"1","order":"5093","possible_hits":"1",},
{"lineNum":"   72","line":"            } else {"},
{"lineNum":"   73","line":"                vec![]"},
{"lineNum":"   74","line":"            },"},
{"lineNum":"   75","line":"            // in the Thunk state, traverse all `HashProx`s","class":"lineCov","hits":"1","order":"4811","possible_hits":"1",},
{"lineNum":"   76","line":"            FirstKBytesProxy::Thunk { ref thunk, .. } => {","class":"linePartCov","hits":"5","order":"4812","possible_hits":"6",},
{"lineNum":"   77","line":"                thunk.iter().fold(vec![], |mut acc, (_fb, hp)| {","class":"linePartCov","hits":"1","order":"4813","possible_hits":"2",},
{"lineNum":"   78","line":"                    acc.append(&mut hp.get_repeats());","class":"lineCov","hits":"1","order":"4837","possible_hits":"1",},
{"lineNum":"   79","line":"                    acc","class":"linePartCov","hits":"1","order":"4838","possible_hits":"2",},
{"lineNum":"   80","line":"                })"},
{"lineNum":"   81","line":"            }"},
{"lineNum":"   82","line":"        }","class":"lineCov","hits":"1","order":"4840","possible_hits":"1",},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"    /// Transition type from a Delay to a Thunk with the introduction of a new file"},
{"lineNum":"   86","line":"    /// Preview both files and add them to the contents of the new Thunk","class":"linePartCov","hits":"2","order":"4663","possible_hits":"3",},
{"lineNum":"   87","line":"    fn transition<T: VFS>(&mut self, vfs: &T, new_id: ID, new_path: &Path) {"},
{"lineNum":"   88","line":"        // convert from a Delay to a Thunk"},
{"lineNum":"   89","line":"        // panics if new belongs in Delay.dups"},
{"lineNum":"   90","line":"        // panics if `self` is of type Thunk"},
{"lineNum":"   91","line":"        // NOTE this involves EITHER a clone of dups OR a promise-violating hack","class":"lineCov","hits":"1","order":"4683","possible_hits":"1",},
{"lineNum":"   92","line":"        let (del_id, del_dups) = match *self {","class":"lineCov","hits":"2","order":"4664","possible_hits":"2",},
{"lineNum":"   93","line":"            FirstKBytesProxy::Delay { id, ref mut dups } => {"},
{"lineNum":"   94","line":"                // this a somewhat hacky potential future speedup"},
{"lineNum":"   95","line":"                // if there are problems with Duplicates being empty, look here"},
{"lineNum":"   96","line":"                // \"steal\" `dups` so we don\'t have to clone it"},
{"lineNum":"   97","line":"                // but we can\'t just take it because we can\'t consume self"},
{"lineNum":"   98","line":"                // OPTION A: the possibly dangerous but more efficient one:"},
{"lineNum":"   99","line":"                //let stolen_dups = ::std::mem::replace(dups, Duplicates(vec![]));"},
{"lineNum":"  100","line":"                //(id, stolen_dups)"},
{"lineNum":"  101","line":"                // OPTION B: the safer but more expensive version:","class":"lineCov","hits":"1","order":"4665","possible_hits":"1",},
{"lineNum":"  102","line":"                (id, dups.clone())"},
{"lineNum":"  103","line":"            }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  104","line":"            _ => unreachable!(),"},
{"lineNum":"  105","line":"        };","class":"linePartCov","hits":"2","order":"4684","possible_hits":"3",},
{"lineNum":"  106","line":"        assert!(new_id != del_id);"},
{"lineNum":"  107","line":"        // Initialize new type\'s variables","class":"lineCov","hits":"1","order":"4685","possible_hits":"1",},
{"lineNum":"  108","line":"        let mut thunk = HashMap::new();","class":"lineCov","hits":"1","order":"4686","possible_hits":"1",},
{"lineNum":"  109","line":"        let mut shortcut = HashMap::new();"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"        // get first bytes of both files","class":"lineCov","hits":"1","order":"4687","possible_hits":"1",},
{"lineNum":"  112","line":"        let new_file = vfs.get_file(new_path).unwrap();","class":"linePartCov","hits":"1","order":"4688","possible_hits":"2",},
{"lineNum":"  113","line":"        let old_file = vfs.get_file(&del_dups.0[0]).unwrap();","class":"linePartCov","hits":"1","order":"4691","possible_hits":"2",},
{"lineNum":"  114","line":"        let new_first_bytes = new_file.get_first_bytes().unwrap();","class":"lineCov","hits":"1","order":"4757","possible_hits":"1",},
{"lineNum":"  115","line":"        let old_first_bytes = old_file.get_first_bytes().unwrap();"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"        // and add them to the map\'s shortcut.","class":"linePartCov","hits":"1","order":"4758","possible_hits":"2",},
{"lineNum":"  118","line":"        shortcut.insert(new_id, new_first_bytes.clone());","class":"linePartCov","hits":"2","order":"4761","possible_hits":"3",},
{"lineNum":"  119","line":"        shortcut.insert(del_id, old_first_bytes.clone());"},
{"lineNum":"  120","line":"        // construct duplicate wraper around the new path and insert into new"},
{"lineNum":"  121","line":"        // hashmap.","class":"linePartCov","hits":"2","order":"4762","possible_hits":"3",},
{"lineNum":"  122","line":"        let new_dups = Duplicates::from(new_path);","class":"linePartCov","hits":"4","order":"4763","possible_hits":"5",},
{"lineNum":"  123","line":"        if new_first_bytes == old_first_bytes {","class":"lineCov","hits":"2","order":"4855","possible_hits":"2",},
{"lineNum":"  124","line":"            let mut hp = HashProxy::new(del_id, del_dups);","class":"linePartCov","hits":"1","order":"4856","possible_hits":"2",},
{"lineNum":"  125","line":"            hp.insert(vfs, new_id, new_dups);","class":"lineCov","hits":"2","order":"4981","possible_hits":"2",},
{"lineNum":"  126","line":"            thunk.insert(old_first_bytes, hp);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  127","line":"        } else {","class":"linePartCov","hits":"1","order":"4777","possible_hits":"2",},
{"lineNum":"  128","line":"            thunk.insert(new_first_bytes, HashProxy::new(new_id, new_dups));","class":"lineCov","hits":"1","order":"4784","possible_hits":"1",},
{"lineNum":"  129","line":"            thunk.insert(old_first_bytes, HashProxy::new(del_id, del_dups));"},
{"lineNum":"  130","line":"        }"},
{"lineNum":"  131","line":"        // replace pointer from delay a pointer to thunk.","class":"linePartCov","hits":"1","order":"4785","possible_hits":"2",},
{"lineNum":"  132","line":"        *self = FirstKBytesProxy::Thunk { thunk, shortcut };","class":"linePartCov","hits":"2","order":"4786","possible_hits":"6",},
{"lineNum":"  133","line":"    }"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    /// Add a new path to the proxy","class":"linePartCov","hits":"2","order":"4654","possible_hits":"3",},
{"lineNum":"  136","line":"    pub fn insert<T: VFS>(&mut self, vfs: &T, id: ID, path: &Path) {","class":"linePartCov","hits":"2","order":"4799","possible_hits":"4",},
{"lineNum":"  137","line":"        match *self {"},
{"lineNum":"  138","line":"            // If a hard link and self is a Delay, insert a hard link to what\'s"},
{"lineNum":"  139","line":"            // already stored in Delay","class":"lineCov","hits":"1","order":"4655","possible_hits":"1",},
{"lineNum":"  140","line":"            FirstKBytesProxy::Delay {","class":"lineCov","hits":"1","order":"4656","possible_hits":"1",},
{"lineNum":"  141","line":"                id: id2,","class":"lineCov","hits":"1","order":"4657","possible_hits":"1",},
{"lineNum":"  142","line":"                ref mut dups,","class":"lineCov","hits":"2","order":"4658","possible_hits":"2",},
{"lineNum":"  143","line":"            } if id == id2 =>","class":"lineCov","hits":"1","order":"5067","possible_hits":"1",},
{"lineNum":"  144","line":"            {"},
{"lineNum":"  145","line":"                dups.push(path);"},
{"lineNum":"  146","line":"            }"},
{"lineNum":"  147","line":"            // If self is a thunk get first bytes and add to shortcut."},
{"lineNum":"  148","line":"            // If a match for a proxy, add"},
{"lineNum":"  149","line":"            // to the proxy; otherwise create a new hashproxy.","class":"lineCov","hits":"1","order":"4788","possible_hits":"1",},
{"lineNum":"  150","line":"            FirstKBytesProxy::Thunk {","class":"lineCov","hits":"1","order":"4789","possible_hits":"1",},
{"lineNum":"  151","line":"                ref mut thunk,"},
{"lineNum":"  152","line":"                ref mut shortcut,","class":"lineCov","hits":"2","order":"4790","possible_hits":"2",},
{"lineNum":"  153","line":"            } => {","class":"linePartCov","hits":"1","order":"4791","possible_hits":"2",},
{"lineNum":"  154","line":"                let file = vfs.get_file(path).unwrap();"},
{"lineNum":"  155","line":"                let first_bytes = file.get_first_bytes().unwrap();","class":"linePartCov","hits":"1","order":"4792","possible_hits":"2",},
{"lineNum":"  156","line":"                //let first_bytes = Self::get_first_bytes(path).unwrap();","class":"linePartCov","hits":"1","order":"4793","possible_hits":"6",},
{"lineNum":"  157","line":"                shortcut.insert(id, first_bytes.clone());"},
{"lineNum":"  158","line":"                match thunk.entry(first_bytes) {","class":"lineCov","hits":"2","order":"4794","possible_hits":"2",},
{"lineNum":"  159","line":"                    // call `insert` on the underlying HashProxy","class":"lineCov","hits":"3","order":"4984","possible_hits":"3",},
{"lineNum":"  160","line":"                    Entry::Occupied(mut occ_entry) => {"},
{"lineNum":"  161","line":"                        occ_entry.get_mut().insert(vfs, id, Duplicates::from(path))"},
{"lineNum":"  162","line":"                    }","class":"lineCov","hits":"1","order":"4795","possible_hits":"1",},
{"lineNum":"  163","line":"                    // not there: create a new HashProxy","class":"lineCov","hits":"2","order":"4796","possible_hits":"2",},
{"lineNum":"  164","line":"                    Entry::Vacant(vac_entry) => {","class":"lineCov","hits":"1","order":"4797","possible_hits":"1",},
{"lineNum":"  165","line":"                        let hp = HashProxy::new(id, Duplicates::from(path));"},
{"lineNum":"  166","line":"                        vac_entry.insert(hp);"},
{"lineNum":"  167","line":"                    }","class":"linePartCov","hits":"1","order":"4798","possible_hits":"2",},
{"lineNum":"  168","line":"                }"},
{"lineNum":"  169","line":"            }"},
{"lineNum":"  170","line":"            // If we are a delay and need to insert a path that is not a hardlink,","class":"lineCov","hits":"1","order":"4662","possible_hits":"1",},
{"lineNum":"  171","line":"            // transition to a thunk"},
{"lineNum":"  172","line":"            FirstKBytesProxy::Delay { .. } => self.transition(vfs, id, path),","class":"lineCov","hits":"1","order":"4787","possible_hits":"1",},
{"lineNum":"  173","line":"        }"},
{"lineNum":"  174","line":"    }"},
{"lineNum":"  175","line":"}"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"// Begin HashProxy"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"/// Proxy of hashes: until two elements have been added, there is no"},
{"lineNum":"  180","line":"/// chance of a collision so put off constructing the hashmap and shortcut"},
{"lineNum":"  181","line":"pub enum HashProxy {"},
{"lineNum":"  182","line":"    // only one unique element has been added"},
{"lineNum":"  183","line":"    Delay {"},
{"lineNum":"  184","line":"        id: ID,"},
{"lineNum":"  185","line":"        dups: Duplicates,"},
{"lineNum":"  186","line":"    },"},
{"lineNum":"  187","line":"    // need to map `Hash`es to a set of `Duplicates`"},
{"lineNum":"  188","line":"    Thunk {"},
{"lineNum":"  189","line":"        thunk: HashMap<Hash, Duplicates>,"},
{"lineNum":"  190","line":"        shortcut: HashMap<ID, Hash>,"},
{"lineNum":"  191","line":"    },"},
{"lineNum":"  192","line":"    // see `FirstKBytesProxy` for more documentation"},
{"lineNum":"  193","line":"    // major difference is that `Duplicates` can contain non-hardlinks"},
{"lineNum":"  194","line":"}"},
{"lineNum":"  195","line":"","class":"lineCov","hits":"2","order":"4778","possible_hits":"2",},
{"lineNum":"  196","line":"","class":"lineCov","hits":"1","order":"4779","possible_hits":"1",},
{"lineNum":"  197","line":"// closely parallels FirstKBytesProxy\'s documentation","class":"linePartCov","hits":"1","order":"4780","possible_hits":"2",},
{"lineNum":"  198","line":"impl HashProxy {"},
{"lineNum":"  199","line":"    //Construct a new hashprxy. As only 1 object, will be of the Delay type."},
{"lineNum":"  200","line":"    fn new(id: ID, dups: Duplicates) -> Self {"},
{"lineNum":"  201","line":"        HashProxy::Delay { id, dups }","class":"linePartCov","hits":"2","order":"4814","possible_hits":"3",},
{"lineNum":"  202","line":"    }","class":"linePartCov","hits":"2","order":"4818","possible_hits":"5",},
{"lineNum":"  203","line":"","class":"lineCov","hits":"1","order":"4815","possible_hits":"1",},
{"lineNum":"  204","line":"    // get all repeats under this node and return as a set of sets of duplicates.","class":"linePartCov","hits":"3","order":"4816","possible_hits":"4",},
{"lineNum":"  205","line":"    /// Check all Duplicates for files associated with multiple Paths","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  206","line":"    fn get_repeats(&self) -> Vec<Duplicates> {"},
{"lineNum":"  207","line":"        match *self {","class":"lineCov","hits":"1","order":"4817","possible_hits":"1",},
{"lineNum":"  208","line":"            HashProxy::Delay { ref dups, .. } => if dups.0.len() >= 2 {"},
{"lineNum":"  209","line":"                vec![dups.clone()]"},
{"lineNum":"  210","line":"            } else {","class":"lineCov","hits":"1","order":"4997","possible_hits":"1",},
{"lineNum":"  211","line":"                vec![]","class":"lineCov","hits":"2","order":"4998","possible_hits":"2",},
{"lineNum":"  212","line":"            },"},
{"lineNum":"  213","line":"            HashProxy::Thunk { ref thunk, .. } => {","class":"lineCov","hits":"2","order":"5007","possible_hits":"2",},
{"lineNum":"  214","line":"                thunk","class":"lineCov","hits":"2","order":"5008","possible_hits":"2",},
{"lineNum":"  215","line":"                    .iter()"},
{"lineNum":"  216","line":"                    .filter_map(|(_hash, repeats)| {"},
{"lineNum":"  217","line":"                        if repeats.0.len() >= 2 {","class":"lineCov","hits":"2","order":"5010","possible_hits":"2",},
{"lineNum":"  218","line":"                            // if there are 2 or more elements"},
{"lineNum":"  219","line":"                            // (including 2 links to 1 file)"},
{"lineNum":"  220","line":"                            Some(repeats.clone())","class":"lineCov","hits":"1","order":"5009","possible_hits":"1",},
{"lineNum":"  221","line":"                        } else {"},
{"lineNum":"  222","line":"                            // exactly one representation on the hard drive","class":"linePartCov","hits":"1","order":"5011","possible_hits":"2",},
{"lineNum":"  223","line":"                            None"},
{"lineNum":"  224","line":"                        }"},
{"lineNum":"  225","line":"                    })"},
{"lineNum":"  226","line":"                    .collect()","class":"lineCov","hits":"1","order":"4819","possible_hits":"1",},
{"lineNum":"  227","line":"            }"},
{"lineNum":"  228","line":"        }","class":"linePartCov","hits":"2","order":"4863","possible_hits":"3",},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":"    // private helper fuction which handles the conversion from Delay to HashProxy::Thunk","class":"linePartCov","hits":"1","order":"4867","possible_hits":"4",},
{"lineNum":"  231","line":"    fn transition<T: VFS>(&mut self, vfs: &T, new_id: ID, new_dups: Duplicates) {","class":"lineCov","hits":"2","order":"4864","possible_hits":"2",},
{"lineNum":"  232","line":"        // convert Delay to Thunk","class":"linePartCov","hits":"1","order":"4865","possible_hits":"2",},
{"lineNum":"  233","line":"        let (del_id, del_dups) = match *self {","class":"lineCov","hits":"2","order":"4866","possible_hits":"2",},
{"lineNum":"  234","line":"            HashProxy::Delay { id, ref mut dups } => {"},
{"lineNum":"  235","line":"                assert!(id != new_id);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  236","line":"                (id, dups.clone())"},
{"lineNum":"  237","line":"            }"},
{"lineNum":"  238","line":"            _ => unreachable!(),","class":"lineCov","hits":"1","order":"4868","possible_hits":"1",},
{"lineNum":"  239","line":"        };","class":"lineCov","hits":"1","order":"4869","possible_hits":"1",},
{"lineNum":"  240","line":"        //Set up variables for thunk state"},
{"lineNum":"  241","line":"        let mut thunk = HashMap::new();"},
{"lineNum":"  242","line":"        let mut shortcut = HashMap::new();","class":"linePartCov","hits":"1","order":"4870","possible_hits":"2",},
{"lineNum":"  243","line":"","class":"linePartCov","hits":"1","order":"4874","possible_hits":"2",},
{"lineNum":"  244","line":"        // get hashes","class":"linePartCov","hits":"1","order":"4875","possible_hits":"2",},
{"lineNum":"  245","line":"        let new_file = vfs.get_file(new_dups.get_path()).unwrap();","class":"lineCov","hits":"1","order":"4924","possible_hits":"1",},
{"lineNum":"  246","line":"        let old_file = vfs.get_file(del_dups.get_path()).unwrap();"},
{"lineNum":"  247","line":"        let new_hash = new_file.get_hash().unwrap();"},
{"lineNum":"  248","line":"        let old_hash = old_file.get_hash().unwrap();","class":"linePartCov","hits":"1","order":"4925","possible_hits":"2",},
{"lineNum":"  249","line":"","class":"linePartCov","hits":"1","order":"4926","possible_hits":"2",},
{"lineNum":"  250","line":"        // insert into shortcut"},
{"lineNum":"  251","line":"        shortcut.insert(new_id, new_hash);"},
{"lineNum":"  252","line":"        shortcut.insert(del_id, old_hash);","class":"lineCov","hits":"2","order":"4927","possible_hits":"2",},
{"lineNum":"  253","line":"","class":"lineCov","hits":"2","order":"4931","possible_hits":"2",},
{"lineNum":"  254","line":"        // thunk: HashMap < Hash, Duplicates >","class":"lineCov","hits":"1","order":"4930","possible_hits":"1",},
{"lineNum":"  255","line":"        thunk.insert(new_hash, new_dups);","class":"linePartCov","hits":"2","order":"4983","possible_hits":"3",},
{"lineNum":"  256","line":"        thunk","class":"linePartCov","hits":"1","order":"4946","possible_hits":"2",},
{"lineNum":"  257","line":"            .entry(old_hash)"},
{"lineNum":"  258","line":"            .or_insert_with(|| Duplicates(vec![]))"},
{"lineNum":"  259","line":"            .append(del_dups);","class":"linePartCov","hits":"1","order":"4978","possible_hits":"2",},
{"lineNum":"  260","line":"","class":"linePartCov","hits":"2","order":"4979","possible_hits":"7",},
{"lineNum":"  261","line":"        // set our pointer to the new thunk state."},
{"lineNum":"  262","line":"        *self = HashProxy::Thunk { thunk, shortcut };"},
{"lineNum":"  263","line":"    }","class":"linePartCov","hits":"2","order":"4857","possible_hits":"3",},
{"lineNum":"  264","line":"","class":"linePartCov","hits":"1","order":"4995","possible_hits":"6",},
{"lineNum":"  265","line":"    // insert Duplicate into the data structure"},
{"lineNum":"  266","line":"    fn insert<T: VFS>(&mut self, vfs: &T, id: ID, dups: Duplicates) {","class":"lineCov","hits":"1","order":"4858","possible_hits":"1",},
{"lineNum":"  267","line":"        match *self {","class":"lineCov","hits":"1","order":"4859","possible_hits":"1",},
{"lineNum":"  268","line":"            // if its just a hard link and we are in Delay: just append it","class":"lineCov","hits":"1","order":"4860","possible_hits":"1",},
{"lineNum":"  269","line":"            HashProxy::Delay {","class":"lineCov","hits":"2","order":"4861","possible_hits":"2",},
{"lineNum":"  270","line":"                id: id2,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"                dups: ref mut dups2,"},
{"lineNum":"  272","line":"            } if id == id2 =>"},
{"lineNum":"  273","line":"            {"},
{"lineNum":"  274","line":"                dups2.append(dups);","class":"lineCov","hits":"1","order":"4985","possible_hits":"1",},
{"lineNum":"  275","line":"            }","class":"lineCov","hits":"1","order":"4986","possible_hits":"1",},
{"lineNum":"  276","line":"            // If we are in a thunk state, just add file and its hash"},
{"lineNum":"  277","line":"            HashProxy::Thunk {","class":"lineCov","hits":"3","order":"4987","possible_hits":"3",},
{"lineNum":"  278","line":"                ref mut thunk,","class":"linePartCov","hits":"1","order":"4988","possible_hits":"2",},
{"lineNum":"  279","line":"                ref mut shortcut,","class":"linePartCov","hits":"1","order":"4989","possible_hits":"2",},
{"lineNum":"  280","line":"            } => {","class":"linePartCov","hits":"1","order":"4990","possible_hits":"3",},
{"lineNum":"  281","line":"                let file = vfs.get_file(dups.get_path()).unwrap();","class":"lineCov","hits":"2","order":"4991","possible_hits":"2",},
{"lineNum":"  282","line":"                let hash = file.get_hash().unwrap();"},
{"lineNum":"  283","line":"                shortcut.insert(id, hash);"},
{"lineNum":"  284","line":"                match thunk.entry(hash) {"},
{"lineNum":"  285","line":"                    Entry::Occupied(mut occ_entry) => {","class":"lineCov","hits":"2","order":"4992","possible_hits":"2",},
{"lineNum":"  286","line":"                        // if files are completely identical","class":"lineCov","hits":"1","order":"4993","possible_hits":"1",},
{"lineNum":"  287","line":"                        // add to the repeat hashtable (the val of the thunk)"},
{"lineNum":"  288","line":"                        // either create it or append to its ID\'s existing entry","class":"lineCov","hits":"1","order":"4999","possible_hits":"1",},
{"lineNum":"  289","line":"                        let repeats = occ_entry.get_mut();","class":"lineCov","hits":"1","order":"5000","possible_hits":"1",},
{"lineNum":"  290","line":"                        repeats.append(dups);"},
{"lineNum":"  291","line":"                    } //  Otherwise just add it to a new hashmap."},
{"lineNum":"  292","line":"                    Entry::Vacant(vacant_entry) => {","class":"linePartCov","hits":"1","order":"4994","possible_hits":"2",},
{"lineNum":"  293","line":"                        vacant_entry.insert(dups);"},
{"lineNum":"  294","line":"                    }"},
{"lineNum":"  295","line":"                }","class":"lineCov","hits":"1","order":"4862","possible_hits":"1",},
{"lineNum":"  296","line":"            }"},
{"lineNum":"  297","line":"            // if a new non-link file is added while self is a delay stage: transition to Thunk"},
{"lineNum":"  298","line":"            HashProxy::Delay { .. } => {","class":"linePartCov","hits":"1","order":"4980","possible_hits":"3",},
{"lineNum":"  299","line":"                self.transition(vfs, id, dups);"},
{"lineNum":"  300","line":"            }"},
{"lineNum":"  301","line":"        }"},
{"lineNum":"  302","line":"    }"},
{"lineNum":"  303","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "smllr-cd1387de2be9f35d", "date" : "2017-11-27 19:54:30", "instrumented" : 135, "covered" : 130,};
var merged_data = [];
