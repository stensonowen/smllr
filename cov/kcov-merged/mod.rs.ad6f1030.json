var data = {lines:[
{"lineNum":"    1","line":"use std::path::Path;"},
{"lineNum":"    2","line":"use std::collections::HashMap;"},
{"lineNum":"    3","line":"use std::collections::hash_map::Entry;"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"pub use super::ID;"},
{"lineNum":"    6","line":"use vfs::{File, MetaData, VFS};"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"pub mod proxy;"},
{"lineNum":"    9","line":"use self::proxy::{Duplicates, FirstKBytesProxy};"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"mod print; // include debug printing info"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"mod test; // include unit tests"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"/// Catalog files, determining lazily if files are identical"},
{"lineNum":"   17","line":"///  by checking filesize, the first K bytes, and then the whole file hash"},
{"lineNum":"   18","line":"///  but only when necessary to check"},
{"lineNum":"   19","line":"pub struct FileCataloger<T: VFS> {"},
{"lineNum":"   20","line":"    catalog: HashMap<u64, FirstKBytesProxy>,"},
{"lineNum":"   21","line":"    vfs: T,"},
{"lineNum":"   22","line":"    // For now, omit the shortcut. We\'re just using the real fs right now, so"},
{"lineNum":"   23","line":"    // a file is just a Path, which has no associated metadata."},
{"lineNum":"   24","line":"    // In the future we could get the ID from the DirWalker for free*, but"},
{"lineNum":"   25","line":"    // for now we need to retrieve the metadata to get the ID which gives the"},
{"lineNum":"   26","line":"    // size for no extra cost. So no need to map ID to size"},
{"lineNum":"   27","line":"}"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"impl<T: VFS> FileCataloger<T> {"},
{"lineNum":"   30","line":"    /// Initilize the filecataloger"},
{"lineNum":"   31","line":"    pub fn new(vfs: T) -> Self {","class":"lineCov","hits":"1","order":"514",},
{"lineNum":"   32","line":"        FileCataloger {","class":"lineCov","hits":"1","order":"517",},
{"lineNum":"   33","line":"            catalog: HashMap::new(),","class":"lineCov","hits":"1","order":"515",},
{"lineNum":"   34","line":"            vfs: vfs,","class":"lineCov","hits":"1","order":"516",},
{"lineNum":"   35","line":"        }"},
{"lineNum":"   36","line":"    }","class":"lineCov","hits":"1","order":"518",},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"    // each Vec<Duplicates> is a vector of all the Duplicates w/ the same content"},
{"lineNum":"   39","line":"    // Each Duplicate is a vector of links that point to one inode"},
{"lineNum":"   40","line":"    /// Check all included Proxies for duplicates"},
{"lineNum":"   41","line":"    pub fn get_repeats(&self) -> Vec<Duplicates> {","class":"lineCov","hits":"1","order":"597",},
{"lineNum":"   42","line":"        let mut all = vec![];","class":"lineCov","hits":"1","order":"598",},
{"lineNum":"   43","line":"        // for each subgrouping (done by size), get all the list of duplicates and"},
{"lineNum":"   44","line":"        // add them to are return variable."},
{"lineNum":"   45","line":"        for (_size, ref fkbp) in &self.catalog {","class":"lineCov","hits":"1","order":"599",},
{"lineNum":"   46","line":"            all.append(&mut fkbp.get_repeats());","class":"lineCov","hits":"1","order":"600",},
{"lineNum":"   47","line":"        }"},
{"lineNum":"   48","line":"        all","class":"lineCov","hits":"1","order":"616",},
{"lineNum":"   49","line":"    }","class":"lineCov","hits":"1","order":"617",},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"    /// Inserts path into the catalog"},
{"lineNum":"   52","line":"    pub fn insert(&mut self, path: &Path) {","class":"lineCov","hits":"1","order":"521",},
{"lineNum":"   53","line":"        // get the metadata (needed for preliminary comparision and storage)"},
{"lineNum":"   54","line":"        let file = self.vfs.get_file(path).expect(\"No such file\");","class":"lineCov","hits":"1","order":"522",},
{"lineNum":"   55","line":"        let md = file.get_metadata().expect(\"IO Error getting Metadata\");","class":"lineCov","hits":"1","order":"523",},
{"lineNum":"   56","line":"        let size: u64 = md.get_len();","class":"lineCov","hits":"1","order":"524",},
{"lineNum":"   57","line":"        let id = ID {","class":"lineCov","hits":"1","order":"527",},
{"lineNum":"   58","line":"            dev: md.get_device().unwrap().0,","class":"lineCov","hits":"1","order":"525",},
{"lineNum":"   59","line":"            inode: md.get_inode().0,","class":"lineCov","hits":"1","order":"526",},
{"lineNum":"   60","line":"        };"},
{"lineNum":"   61","line":"        // sort by size into the appropriate proxy"},
{"lineNum":"   62","line":"        match self.catalog.entry(size) {","class":"lineCov","hits":"1","order":"528",},
{"lineNum":"   63","line":"            // If another file of that size has been included, insert into that proxy"},
{"lineNum":"   64","line":"            Entry::Occupied(mut occ_entry) => occ_entry.get_mut().insert(&self.vfs, id, path),","class":"lineCov","hits":"1","order":"529",},
{"lineNum":"   65","line":"            // otherwise create a new firstkbytesproxy with path as the delayed insert."},
{"lineNum":"   66","line":"            Entry::Vacant(vac_entry) => {","class":"lineCov","hits":"1","order":"530",},
{"lineNum":"   67","line":"                vac_entry.insert(FirstKBytesProxy::new(id, path));","class":"lineCov","hits":"1","order":"531",},
{"lineNum":"   68","line":"            }"},
{"lineNum":"   69","line":"        }"},
{"lineNum":"   70","line":"    }","class":"lineCov","hits":"1","order":"540",},
{"lineNum":"   71","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "smllr-cd1387de2be9f35d", "date" : "2017-11-27 19:54:30", "instrumented" : 23, "covered" : 23,};
var merged_data = [];
