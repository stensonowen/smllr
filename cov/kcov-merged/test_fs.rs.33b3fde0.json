var data = {lines:[
{"lineNum":"    1","line":"// mock filesystem for testing"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"use std::io;"},
{"lineNum":"    4","line":"use std::rc::Rc;"},
{"lineNum":"    5","line":"use std::cell::RefCell;"},
{"lineNum":"    6","line":"use std::path::{Path, PathBuf};"},
{"lineNum":"    7","line":"use std::time::{self, SystemTime};"},
{"lineNum":"    8","line":"use std::collections::{HashMap, HashSet};"},
{"lineNum":"    9","line":"//RUST NOTE: `super` means up a module (often up a directory)"},
{"lineNum":"   10","line":"use vfs::{DeviceId, File, FileType, Inode, MetaData, VFS};"},
{"lineNum":"   11","line":"use super::{FirstBytes, Hash, FIRST_K_BYTES};"},
{"lineNum":"   12","line":"use super::super::ID;"},
{"lineNum":"   13","line":"use md5;"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"/// `TestMD` is the mock metadata struct."},
{"lineNum":"   16","line":"#[derive(Debug, Clone, Copy, PartialEq)]","class":"lineCov","hits":"1","order":"109",},
{"lineNum":"   17","line":"pub struct TestMD {"},
{"lineNum":"   18","line":"    len: u64,"},
{"lineNum":"   19","line":"    creation: SystemTime,"},
{"lineNum":"   20","line":"    kind: FileType,"},
{"lineNum":"   21","line":"    id: ID,"},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"//implementation of the MetaData trait for testMD."},
{"lineNum":"   25","line":"impl MetaData for TestMD {"},
{"lineNum":"   26","line":"    fn get_len(&self) -> u64 {","class":"lineCov","hits":"1","order":"114",},
{"lineNum":"   27","line":"        self.len","class":"lineCov","hits":"1","order":"115",},
{"lineNum":"   28","line":"    }","class":"lineCov","hits":"1","order":"116",},
{"lineNum":"   29","line":"    fn get_creation_time(&self) -> io::Result<SystemTime> {","class":"lineCov","hits":"1","order":"388",},
{"lineNum":"   30","line":"        Ok(self.creation)","class":"lineCov","hits":"1","order":"390",},
{"lineNum":"   31","line":"    }","class":"lineCov","hits":"1","order":"392",},
{"lineNum":"   32","line":"    fn get_type(&self) -> FileType {","class":"lineCov","hits":"1","order":"849",},
{"lineNum":"   33","line":"        self.kind","class":"lineCov","hits":"1","order":"850",},
{"lineNum":"   34","line":"    }","class":"lineCov","hits":"1","order":"851",},
{"lineNum":"   35","line":"    fn get_inode(&self) -> Inode {","class":"lineCov","hits":"1","order":"274",},
{"lineNum":"   36","line":"        Inode(self.id.inode)","class":"lineCov","hits":"1","order":"275",},
{"lineNum":"   37","line":"    }","class":"lineCov","hits":"1","order":"276",},
{"lineNum":"   38","line":"    fn get_device(&self) -> io::Result<DeviceId> {","class":"lineCov","hits":"1","order":"211",},
{"lineNum":"   39","line":"        Ok(DeviceId(self.id.dev))","class":"lineCov","hits":"1","order":"212",},
{"lineNum":"   40","line":"    }","class":"lineCov","hits":"1","order":"213",},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"// TestMD must be easy to make and also customize for unit testing"},
{"lineNum":"   44","line":"// We provide a series of chainable setters to easily construct test objects"},
{"lineNum":"   45","line":"// e.g. `TestMD::new().with_len(4096).with_id(42)`"},
{"lineNum":"   46","line":"impl TestMD {"},
{"lineNum":"   47","line":"    pub fn new() -> Self {","class":"lineCov","hits":"1","order":"46",},
{"lineNum":"   48","line":"        TestMD {","class":"lineCov","hits":"1","order":"50",},
{"lineNum":"   49","line":"            len: 0,"},
{"lineNum":"   50","line":"            creation: SystemTime::now(),","class":"lineCov","hits":"1","order":"47",},
{"lineNum":"   51","line":"            kind: FileType::File,","class":"lineCov","hits":"1","order":"48",},
{"lineNum":"   52","line":"            id: ID { dev: 0, inode: 0 },","class":"lineCov","hits":"1","order":"49",},
{"lineNum":"   53","line":"        }"},
{"lineNum":"   54","line":"    }","class":"lineCov","hits":"1","order":"51",},
{"lineNum":"   55","line":"    pub fn with_len(mut self, n: u64) -> Self {"},
{"lineNum":"   56","line":"        self.len = n;"},
{"lineNum":"   57","line":"        self"},
{"lineNum":"   58","line":"    }"},
{"lineNum":"   59","line":"    pub fn with_creation_time(mut self, t: SystemTime) -> Self {","class":"lineCov","hits":"1","order":"333",},
{"lineNum":"   60","line":"        self.creation = t;","class":"lineCov","hits":"1","order":"334",},
{"lineNum":"   61","line":"        self","class":"lineCov","hits":"1","order":"336",},
{"lineNum":"   62","line":"    }","class":"lineCov","hits":"1","order":"337",},
{"lineNum":"   63","line":"    pub fn with_kind(mut self, k: FileType) -> Self {"},
{"lineNum":"   64","line":"        self.kind = k;"},
{"lineNum":"   65","line":"        self"},
{"lineNum":"   66","line":"    }"},
{"lineNum":"   67","line":"    pub fn with_id(mut self, id: ID) -> Self {","class":"lineCov","hits":"1","order":"141",},
{"lineNum":"   68","line":"        self.id = id;","class":"lineCov","hits":"1","order":"142",},
{"lineNum":"   69","line":"        self","class":"lineCov","hits":"1","order":"143",},
{"lineNum":"   70","line":"    }","class":"lineCov","hits":"1","order":"144",},
{"lineNum":"   71","line":"}"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"/// `TestFile` denotes a mockfile."},
{"lineNum":"   74","line":"/// Note that we are mocking the linux-style filesystem"},
{"lineNum":"   75","line":"/// where many things are \'files\', including directories,"},
{"lineNum":"   76","line":"/// links, devices (/dev/sda might be familair)."},
{"lineNum":"   77","line":"#[derive(Debug, Clone, PartialEq)]","class":"lineCov","hits":"1","order":"102",},
{"lineNum":"   78","line":"pub struct TestFile {"},
{"lineNum":"   79","line":"    path: PathBuf,","class":"lineCov","hits":"1","order":"103",},
{"lineNum":"   80","line":"    contents: Option<String>,","class":"lineCov","hits":"1","order":"104",},
{"lineNum":"   81","line":"    kind: FileType,","class":"lineCov","hits":"1","order":"105",},
{"lineNum":"   82","line":"    inode: Inode,","class":"lineCov","hits":"1","order":"106",},
{"lineNum":"   83","line":"    metadata: Option<TestMD>,","class":"lineCov","hits":"1","order":"107",},
{"lineNum":"   84","line":"}"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"// build up a File object for mock testing"},
{"lineNum":"   87","line":"// Chainable setters to easily construct test objects"},
{"lineNum":"   88","line":"// e.g. `TestFile::new().with_kind(FileType::Dir).with_inode(42)`"},
{"lineNum":"   89","line":"impl TestFile {"},
{"lineNum":"   90","line":"    pub fn new(s: &str) -> Self {","class":"lineCov","hits":"1","order":"38",},
{"lineNum":"   91","line":"        TestFile {","class":"lineCov","hits":"1","order":"44",},
{"lineNum":"   92","line":"            path: PathBuf::from(s),","class":"lineCov","hits":"1","order":"39",},
{"lineNum":"   93","line":"            contents: None,","class":"lineCov","hits":"1","order":"40",},
{"lineNum":"   94","line":"            kind: FileType::File,","class":"lineCov","hits":"1","order":"41",},
{"lineNum":"   95","line":"            inode: Inode(0),","class":"lineCov","hits":"1","order":"42",},
{"lineNum":"   96","line":"            metadata: None,","class":"lineCov","hits":"1","order":"43",},
{"lineNum":"   97","line":"        }"},
{"lineNum":"   98","line":"    }","class":"lineCov","hits":"1","order":"45",},
{"lineNum":"   99","line":"    pub fn with_contents(mut self, c: String) -> Self {","class":"lineCov","hits":"1","order":"450",},
{"lineNum":"  100","line":"        if let Some(ref mut md) = self.metadata {","class":"lineCov","hits":"1","order":"451",},
{"lineNum":"  101","line":"            md.len = c.len() as u64;","class":"lineNoCov","hits":"0",},
{"lineNum":"  102","line":"        }"},
{"lineNum":"  103","line":"        self.contents = Some(c);","class":"lineCov","hits":"1","order":"452",},
{"lineNum":"  104","line":"        self","class":"lineCov","hits":"1","order":"453",},
{"lineNum":"  105","line":"    }","class":"lineCov","hits":"1","order":"454",},
{"lineNum":"  106","line":"    pub fn with_kind(mut self, k: FileType) -> Self {","class":"lineCov","hits":"1","order":"135",},
{"lineNum":"  107","line":"        if let Some(ref mut md) = self.metadata {","class":"lineCov","hits":"1","order":"136",},
{"lineNum":"  108","line":"            md.kind = k;","class":"lineNoCov","hits":"0",},
{"lineNum":"  109","line":"        }"},
{"lineNum":"  110","line":"        self.kind = k;","class":"lineCov","hits":"1","order":"137",},
{"lineNum":"  111","line":"        self","class":"lineCov","hits":"1","order":"138",},
{"lineNum":"  112","line":"    }","class":"lineCov","hits":"1","order":"139",},
{"lineNum":"  113","line":"    pub fn with_inode(mut self, i: u64) -> Self {","class":"lineCov","hits":"1","order":"237",},
{"lineNum":"  114","line":"        if let Some(ref mut md) = self.metadata {","class":"lineCov","hits":"1","order":"238",},
{"lineNum":"  115","line":"            md.id.inode = i;","class":"lineCov","hits":"1","order":"470",},
{"lineNum":"  116","line":"        }"},
{"lineNum":"  117","line":"        self.inode = Inode(i);","class":"lineCov","hits":"1","order":"239",},
{"lineNum":"  118","line":"        self","class":"lineCov","hits":"1","order":"240",},
{"lineNum":"  119","line":"    }","class":"lineCov","hits":"1","order":"241",},
{"lineNum":"  120","line":"    pub fn with_metadata(mut self, mut md: TestMD) -> Self {","class":"lineCov","hits":"1","order":"52",},
{"lineNum":"  121","line":"        // fix filetype discrepancy"},
{"lineNum":"  122","line":"        if self.kind != FileType::File {","class":"lineCov","hits":"1","order":"53",},
{"lineNum":"  123","line":"            md.kind = self.kind;","class":"lineCov","hits":"1","order":"145",},
{"lineNum":"  124","line":"        } else if md.kind != FileType::File {","class":"lineCov","hits":"1","order":"55",},
{"lineNum":"  125","line":"            self.kind = md.kind;","class":"lineNoCov","hits":"0",},
{"lineNum":"  126","line":"        }"},
{"lineNum":"  127","line":"        // fix len discrepancy"},
{"lineNum":"  128","line":"        if let Some(ref c) = self.contents {","class":"lineCov","hits":"1","order":"56",},
{"lineNum":"  129","line":"            md.len = c.len() as u64;","class":"lineCov","hits":"1","order":"456",},
{"lineNum":"  130","line":"        } else if md.len != 0 {","class":"lineCov","hits":"1","order":"57",},
{"lineNum":"  131","line":"            // for now do nothing"},
{"lineNum":"  132","line":"            // it is okay for `len` to be >0 and `contents` to be empty"},
{"lineNum":"  133","line":"            //let contents = ::std::iter::repeat(\'?\').take(md.len as usize).collect();"},
{"lineNum":"  134","line":"            //self.contents = Some(contents);"},
{"lineNum":"  135","line":"        }"},
{"lineNum":"  136","line":"        // fix inode discrepancy"},
{"lineNum":"  137","line":"        if self.inode.0 != 0 {","class":"lineCov","hits":"1","order":"58",},
{"lineNum":"  138","line":"            md.id.inode = self.inode.0;","class":"lineCov","hits":"1","order":"243",},
{"lineNum":"  139","line":"        } else if md.id.inode != 0 {","class":"lineCov","hits":"1","order":"59",},
{"lineNum":"  140","line":"            self.inode.0 = md.id.inode;","class":"lineCov","hits":"1","order":"146",},
{"lineNum":"  141","line":"        }"},
{"lineNum":"  142","line":"        self.metadata = Some(md);","class":"lineCov","hits":"1","order":"60",},
{"lineNum":"  143","line":"        self","class":"lineCov","hits":"1","order":"61",},
{"lineNum":"  144","line":"    }","class":"lineCov","hits":"1","order":"62",},
{"lineNum":"  145","line":"}"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"/// Implementation of the File trait for `TestFile`"},
{"lineNum":"  148","line":"impl File for TestFile {"},
{"lineNum":"  149","line":"    type MD = TestMD;"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    fn get_path(&self) -> PathBuf {","class":"lineCov","hits":"1","order":"886",},
{"lineNum":"  152","line":"        self.path.clone()","class":"lineCov","hits":"1","order":"887",},
{"lineNum":"  153","line":"    }","class":"lineCov","hits":"1","order":"888",},
{"lineNum":"  154","line":"    fn get_inode(&self) -> io::Result<Inode> {","class":"lineCov","hits":"1","order":"172",},
{"lineNum":"  155","line":"        Ok(self.inode)","class":"lineCov","hits":"1","order":"175",},
{"lineNum":"  156","line":"    }","class":"lineCov","hits":"1","order":"177",},
{"lineNum":"  157","line":"    fn get_type(&self) -> io::Result<FileType> {","class":"lineCov","hits":"1","order":"889",},
{"lineNum":"  158","line":"        Ok(self.kind)","class":"lineCov","hits":"1","order":"890",},
{"lineNum":"  159","line":"    }","class":"lineCov","hits":"1","order":"891",},
{"lineNum":"  160","line":"    fn get_metadata(&self) -> io::Result<TestMD> {","class":"lineCov","hits":"1","order":"111",},
{"lineNum":"  161","line":"        self.metadata","class":"lineCov","hits":"1","order":"112",},
{"lineNum":"  162","line":"            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"No MD\"))","class":"lineNoCov","hits":"0",},
{"lineNum":"  163","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  164","line":"    fn get_first_bytes(&self) -> io::Result<FirstBytes> {","class":"lineCov","hits":"1","order":"113",},
{"lineNum":"  165","line":"        // read the first K bytes of the file","class":"lineCov","hits":"1","order":"562",},
{"lineNum":"  166","line":"        // if the file is less than K bytes, the remaining bytes are treated as zeros"},
{"lineNum":"  167","line":"        if let Some(ref cont) = self.contents {"},
{"lineNum":"  168","line":"            let mut bytes = [0u8; FIRST_K_BYTES];","class":"lineCov","hits":"1","order":"563",},
{"lineNum":"  169","line":"            for (c, b) in cont.bytes().zip(bytes.iter_mut()) {","class":"lineCov","hits":"1","order":"564",},
{"lineNum":"  170","line":"                *b = c;","class":"lineCov","hits":"1","order":"565",},
{"lineNum":"  171","line":"            }","class":"lineCov","hits":"1","order":"566",},
{"lineNum":"  172","line":"            Ok(FirstBytes(bytes))"},
{"lineNum":"  173","line":"        } else {","class":"lineCov","hits":"1","order":"567",},
{"lineNum":"  174","line":"            Err(io::Error::new(io::ErrorKind::NotFound, \"No contents set\"))"},
{"lineNum":"  175","line":"        }","class":"lineNoCov","hits":"0",},
{"lineNum":"  176","line":"    }"},
{"lineNum":"  177","line":"    fn get_hash(&self) -> io::Result<Hash> {","class":"lineCov","hits":"1","order":"568",},
{"lineNum":"  178","line":"        // hash the contents of the file","class":"lineCov","hits":"1","order":"644",},
{"lineNum":"  179","line":"        if let Some(ref cont) = self.contents {"},
{"lineNum":"  180","line":"            Ok(*md5::compute(cont))","class":"lineCov","hits":"1","order":"645",},
{"lineNum":"  181","line":"        } else {","class":"lineCov","hits":"1","order":"646",},
{"lineNum":"  182","line":"            Err(io::Error::new(io::ErrorKind::NotFound, \"No contents set\"))"},
{"lineNum":"  183","line":"        }","class":"lineNoCov","hits":"0",},
{"lineNum":"  184","line":"    }"},
{"lineNum":"  185","line":"}","class":"lineCov","hits":"1","order":"647",},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"/// `TestFileSystem` denotes a Mock Filesystem we use instead of risking"},
{"lineNum":"  188","line":"/// our own data or dealing with the actual filesystem"},
{"lineNum":"  189","line":"#[derive(Debug)]"},
{"lineNum":"  190","line":"pub struct TestFileSystem {"},
{"lineNum":"  191","line":"    files: HashMap<PathBuf, TestFile>,"},
{"lineNum":"  192","line":"    symlinks: HashMap<PathBuf, (TestFile, PathBuf)>,"},
{"lineNum":"  193","line":"}"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"impl TestFileSystem {"},
{"lineNum":"  196","line":"    // private helper functions:"},
{"lineNum":"  197","line":"    // gets the number of files on the mock system."},
{"lineNum":"  198","line":"    // The name denotes its use when adding a new inode,"},
{"lineNum":"  199","line":"    // as sequentially, they are numbered 0, 1, ..."},
{"lineNum":"  200","line":"    // Ergo with N inodes, the next inode will be"},
{"lineNum":"  201","line":"    // given the id N."},
{"lineNum":"  202","line":"    fn get_next_inode(&self) -> Inode {"},
{"lineNum":"  203","line":"        Inode((self.files.len() + self.symlinks.len()) as u64)","class":"lineCov","hits":"1","order":"21",},
{"lineNum":"  204","line":"    }","class":"lineCov","hits":"1","order":"22",},
{"lineNum":"  205","line":"    // Creates a new MockFile with FileType kind and a Path of path","class":"lineCov","hits":"1","order":"23",},
{"lineNum":"  206","line":"    // Not used to create a new symlink."},
{"lineNum":"  207","line":"    fn create_regular(&mut self, path: &Path, kind: FileType) {"},
{"lineNum":"  208","line":"        let inode = self.get_next_inode();","class":"lineCov","hits":"1","order":"19",},
{"lineNum":"  209","line":"        // Create the metadata for the file","class":"lineCov","hits":"1","order":"20",},
{"lineNum":"  210","line":"        let md = TestMD {"},
{"lineNum":"  211","line":"            len: 0,","class":"lineCov","hits":"1","order":"27",},
{"lineNum":"  212","line":"            creation: time::UNIX_EPOCH,"},
{"lineNum":"  213","line":"            kind,"},
{"lineNum":"  214","line":"            id: ID {","class":"lineCov","hits":"1","order":"24",},
{"lineNum":"  215","line":"                inode: inode.0,","class":"lineCov","hits":"1","order":"26",},
{"lineNum":"  216","line":"                dev: 0,","class":"lineCov","hits":"1","order":"25",},
{"lineNum":"  217","line":"            },"},
{"lineNum":"  218","line":"        };"},
{"lineNum":"  219","line":"        // Create the File."},
{"lineNum":"  220","line":"        let tf = TestFile {"},
{"lineNum":"  221","line":"            path: path.to_owned(),","class":"lineCov","hits":"1","order":"33",},
{"lineNum":"  222","line":"            kind,","class":"lineCov","hits":"1","order":"28",},
{"lineNum":"  223","line":"            inode,","class":"lineCov","hits":"1","order":"29",},
{"lineNum":"  224","line":"            contents: None,","class":"lineCov","hits":"1","order":"30",},
{"lineNum":"  225","line":"            metadata: Some(md),","class":"lineCov","hits":"1","order":"31",},
{"lineNum":"  226","line":"        };","class":"lineCov","hits":"1","order":"32",},
{"lineNum":"  227","line":"        // Add the file to the filesystem."},
{"lineNum":"  228","line":"        self.files.insert(path.to_owned(), tf);"},
{"lineNum":"  229","line":"    }","class":"lineCov","hits":"1","order":"34",},
{"lineNum":"  230","line":"","class":"lineCov","hits":"1","order":"35",},
{"lineNum":"  231","line":"    /// constructor: initializes self."},
{"lineNum":"  232","line":"    pub fn new() -> Rc<RefCell<Self>> {"},
{"lineNum":"  233","line":"        Rc::new(RefCell::new(TestFileSystem {","class":"lineCov","hits":"1","order":"4",},
{"lineNum":"  234","line":"            files: HashMap::new(),","class":"lineCov","hits":"1","order":"11",},
{"lineNum":"  235","line":"            symlinks: HashMap::new(),","class":"lineCov","hits":"1","order":"5",},
{"lineNum":"  236","line":"        }))","class":"lineCov","hits":"1","order":"10",},
{"lineNum":"  237","line":"    }","class":"lineNoCov","hits":"0",},
{"lineNum":"  238","line":"    /// get size","class":"lineCov","hits":"1","order":"14",},
{"lineNum":"  239","line":"    pub fn num_elements(&self) -> usize {"},
{"lineNum":"  240","line":"        self.files.len() + self.symlinks.len()","class":"lineCov","hits":"1","order":"129",},
{"lineNum":"  241","line":"    }","class":"lineCov","hits":"1","order":"130",},
{"lineNum":"  242","line":"    /// get number of unique inodes","class":"lineCov","hits":"1","order":"131",},
{"lineNum":"  243","line":"    pub fn num_inodes(&self) -> usize {"},
{"lineNum":"  244","line":"        let inodes: HashSet<_> = self.files","class":"lineCov","hits":"1","order":"158",},
{"lineNum":"  245","line":"            .iter()","class":"lineCov","hits":"1","order":"159",},
{"lineNum":"  246","line":"            .map(|f| f.1.get_inode().unwrap())"},
{"lineNum":"  247","line":"            .collect();","class":"lineCov","hits":"1","order":"169",},
{"lineNum":"  248","line":"        inodes.len()"},
{"lineNum":"  249","line":"    }","class":"lineCov","hits":"1","order":"196",},
{"lineNum":"  250","line":"    /// Creates a new file at path. Anologous to \'$touch path\'","class":"lineCov","hits":"1","order":"197",},
{"lineNum":"  251","line":"    pub fn create_file<P: AsRef<Path>>(&mut self, path: P) {"},
{"lineNum":"  252","line":"        self.create_regular(path.as_ref(), FileType::File);","class":"lineCov","hits":"1","order":"747",},
{"lineNum":"  253","line":"    }","class":"lineCov","hits":"1","order":"748",},
{"lineNum":"  254","line":"    /// Creates a new directory with path. Anologus to \'$mkdir path\'","class":"lineCov","hits":"1","order":"749",},
{"lineNum":"  255","line":"    pub fn create_dir<P: AsRef<Path>>(&mut self, path: P) {"},
{"lineNum":"  256","line":"        self.create_regular(path.as_ref(), FileType::Dir);","class":"lineCov","hits":"1","order":"17",},
{"lineNum":"  257","line":"    }","class":"lineCov","hits":"1","order":"18",},
{"lineNum":"  258","line":"    /// Creates a new symlink from path to target. analogous to","class":"lineCov","hits":"1","order":"36",},
{"lineNum":"  259","line":"    /// `ln -s -t target path`"},
{"lineNum":"  260","line":"    pub fn create_symlink<P: AsRef<Path>>(&mut self, path: P, target: P) {"},
{"lineNum":"  261","line":"        // Create the symlink file.","class":"lineCov","hits":"1","order":"831",},
{"lineNum":"  262","line":"        let tf = TestFile {"},
{"lineNum":"  263","line":"            path: path.as_ref().to_owned(),","class":"lineCov","hits":"1","order":"837",},
{"lineNum":"  264","line":"            kind: FileType::Symlink,","class":"lineCov","hits":"1","order":"832",},
{"lineNum":"  265","line":"            inode: self.get_next_inode(),","class":"lineCov","hits":"1","order":"833",},
{"lineNum":"  266","line":"            contents: None,","class":"lineCov","hits":"1","order":"834",},
{"lineNum":"  267","line":"            metadata: None,","class":"lineCov","hits":"1","order":"835",},
{"lineNum":"  268","line":"        };","class":"lineCov","hits":"1","order":"836",},
{"lineNum":"  269","line":"        // add the symlink to the filesystem.","class":"lineNoCov","hits":"0",},
{"lineNum":"  270","line":"        let val = (tf, target.as_ref().to_owned());"},
{"lineNum":"  271","line":"        self.symlinks.insert(path.as_ref().to_owned(), val);","class":"lineCov","hits":"1","order":"838",},
{"lineNum":"  272","line":"    }","class":"lineCov","hits":"1","order":"839",},
{"lineNum":"  273","line":"    /// Register a new file","class":"lineCov","hits":"1","order":"840",},
{"lineNum":"  274","line":"    pub fn add(&mut self, tf: TestFile) {"},
{"lineNum":"  275","line":"        self.files.insert(tf.path.to_owned(), tf);","class":"lineCov","hits":"1","order":"63",},
{"lineNum":"  276","line":"    }","class":"lineCov","hits":"1","order":"64",},
{"lineNum":"  277","line":"","class":"lineCov","hits":"1","order":"65",},
{"lineNum":"  278","line":"    // getters for the Mock Filesystem."},
{"lineNum":"  279","line":"    // RUST SYNTAX: <\'a> is a lifetime paramater. Lifetimes are pretty"},
{"lineNum":"  280","line":"    // unique to rust; essentially they are used to pass the parent"},
{"lineNum":"  281","line":"    // through so they are invalidated when the parent is."},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    /// Resolves the path into a TestFile"},
{"lineNum":"  284","line":"    fn lookup<\'a>(&\'a self, path: &Path) -> io::Result<&\'a TestFile> {"},
{"lineNum":"  285","line":"        if let Some(tf) = self.files.get(path) {","class":"lineCov","hits":"1","order":"916",},
{"lineNum":"  286","line":"            Ok(tf)","class":"lineCov","hits":"1","order":"917",},
{"lineNum":"  287","line":"        } else {","class":"lineNoCov","hits":"0",},
{"lineNum":"  288","line":"            // traverse the symlink chain","class":"lineNoCov","hits":"0",},
{"lineNum":"  289","line":"            let mut cur = self.symlinks.get(path);"},
{"lineNum":"  290","line":"            // `seen` can\'t be a Hash table because SystemTime isn\'t Hash","class":"lineCov","hits":"1","order":"918",},
{"lineNum":"  291","line":"            let mut seen: Vec<&Path> = vec![];"},
{"lineNum":"  292","line":"            while let Some(c) = cur {","class":"lineCov","hits":"1","order":"919",},
{"lineNum":"  293","line":"                if seen.contains(&c.1.as_path()) {","class":"lineCov","hits":"1","order":"920",},
{"lineNum":"  294","line":"                    // infinite symlink loop","class":"lineCov","hits":"1","order":"921",},
{"lineNum":"  295","line":"                    return Err(io::Error::from_raw_os_error(40));"},
{"lineNum":"  296","line":"                } else {","class":"lineCov","hits":"1","order":"924",},
{"lineNum":"  297","line":"                    seen.push(&c.1);"},
{"lineNum":"  298","line":"                    cur = self.symlinks.get(&c.1);","class":"lineCov","hits":"1","order":"922",},
{"lineNum":"  299","line":"                }","class":"lineCov","hits":"1","order":"923",},
{"lineNum":"  300","line":"            }"},
{"lineNum":"  301","line":"            Err(io::Error::new(io::ErrorKind::NotFound, \"No such file\"))"},
{"lineNum":"  302","line":"        }","class":"lineNoCov","hits":"0",},
{"lineNum":"  303","line":"    }","class":"lineCov","hits":"1","order":"925",},
{"lineNum":"  304","line":"}","class":"lineCov","hits":"1","order":"926",},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"// Implementation of the VFS interface for the whole of the Mock File System."},
{"lineNum":"  307","line":"impl VFS for Rc<RefCell<TestFileSystem>> {"},
{"lineNum":"  308","line":"    type FileIter = TestFile;"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"    /// VFS::list_dir(p)  gets an iterator over the contents of p."},
{"lineNum":"  311","line":"    fn list_dir<P: AsRef<Path>>("},
{"lineNum":"  312","line":"        &self,","class":"lineCov","hits":"1","order":"867",},
{"lineNum":"  313","line":"        p: P,","class":"lineCov","hits":"1","order":"868",},
{"lineNum":"  314","line":"    ) -> io::Result<Box<Iterator<Item = io::Result<TestFile>>>> {","class":"lineCov","hits":"1","order":"869",},
{"lineNum":"  315","line":"        let mut v = vec![];","class":"lineNoCov","hits":"0",},
{"lineNum":"  316","line":"        let fs = self.borrow();","class":"lineCov","hits":"1","order":"870",},
{"lineNum":"  317","line":"        // collect all files which are children of p","class":"lineCov","hits":"1","order":"871",},
{"lineNum":"  318","line":"        let is_root = p.as_ref().components().count() == 1;"},
{"lineNum":"  319","line":"        for (path, file) in &fs.files {","class":"lineCov","hits":"1","order":"872",},
{"lineNum":"  320","line":"            if path.parent() == Some(p.as_ref()) || (is_root && path.components().count() == 2) {","class":"lineCov","hits":"1","order":"873",},
{"lineNum":"  321","line":"                // include a file if it\'s parent is in `p`","class":"lineCov","hits":"1","order":"874",},
{"lineNum":"  322","line":"                // or if `p` is the root and `path` is 1 level down"},
{"lineNum":"  323","line":"                v.push(Ok(file.clone()));"},
{"lineNum":"  324","line":"            }","class":"lineCov","hits":"1","order":"875",},
{"lineNum":"  325","line":"        }"},
{"lineNum":"  326","line":"        // collect all symlinks which are children of p"},
{"lineNum":"  327","line":"        for (src, &(ref file, ref _dst)) in &fs.symlinks {"},
{"lineNum":"  328","line":"            if src.parent() == Some(p.as_ref()) || p.as_ref().parent().is_none() {","class":"lineCov","hits":"1","order":"876",},
{"lineNum":"  329","line":"                v.push(Ok(file.clone()));","class":"lineCov","hits":"1","order":"877",},
{"lineNum":"  330","line":"            }","class":"lineCov","hits":"1","order":"878",},
{"lineNum":"  331","line":"        }"},
{"lineNum":"  332","line":"        // return the iterator."},
{"lineNum":"  333","line":"        Ok(Box::new(v.into_iter()))"},
{"lineNum":"  334","line":"    }","class":"lineCov","hits":"1","order":"879",},
{"lineNum":"  335","line":"","class":"lineCov","hits":"1","order":"880",},
{"lineNum":"  336","line":"    //RUST NOTE: match is roughly equivlent to the c\'s \'switch\'."},
{"lineNum":"  337","line":"    // match expr {"},
{"lineNum":"  338","line":"    //     expr1 => block,"},
{"lineNum":"  339","line":"    //     expr2 => block,"},
{"lineNum":"  340","line":"    // }"},
{"lineNum":"  341","line":"    // is equivlent to"},
{"lineNum":"  342","line":"    // switch (expr) {"},
{"lineNum":"  343","line":"    //     case expr1:"},
{"lineNum":"  344","line":"    //         block"},
{"lineNum":"  345","line":"    //     case expr2:"},
{"lineNum":"  346","line":"    //         block"},
{"lineNum":"  347","line":"    //}"},
{"lineNum":"  348","line":"    //"},
{"lineNum":"  349","line":"    // The \'_\' expresion when used in match is equivelent to default in c"},
{"lineNum":"  350","line":"    //"},
{"lineNum":"  351","line":"    //Match also supports deconstructing and binding. see"},
{"lineNum":"  352","line":"    // https://rustbyexample.com/flow_control/match.html"},
{"lineNum":"  353","line":"    // for more information."},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"    /// VFS::get_metadata gets the Metadata of Path"},
{"lineNum":"  356","line":"    /// FileType of path cannot be symlink; they are handled diffrently; use"},
{"lineNum":"  357","line":"    /// VFS::get_symlink_metadata for symlinks"},
{"lineNum":"  358","line":"    fn get_metadata<P: AsRef<Path>>(&self, path: P) -> io::Result<<Self::FileIter as File>::MD> {"},
{"lineNum":"  359","line":"        let fs = self.borrow();","class":"lineCov","hits":"1","order":"803",},
{"lineNum":"  360","line":"        match fs.files.get(path.as_ref()) {","class":"lineCov","hits":"1","order":"804",},
{"lineNum":"  361","line":"            Some(f) => f.get_metadata(),","class":"lineCov","hits":"1","order":"805",},
{"lineNum":"  362","line":"            None => match fs.symlinks.get(path.as_ref()) {","class":"lineCov","hits":"1","order":"806",},
{"lineNum":"  363","line":"                Some(&(_, ref p)) => fs.lookup(p).and_then(|f| f.get_metadata()),"},
{"lineNum":"  364","line":"                None => Err(io::Error::new(io::ErrorKind::NotFound, \"No such file\")),","class":"lineCov","hits":"1","order":"807",},
{"lineNum":"  365","line":"            },","class":"lineCov","hits":"1","order":"808",},
{"lineNum":"  366","line":"        }","class":"lineCov","hits":"1","order":"809",},
{"lineNum":"  367","line":"    }"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"    /// VFS::get_symlink_metadata(p) gets the metadata for symlink p."},
{"lineNum":"  370","line":"    fn get_symlink_metadata<P: AsRef<Path>>(","class":"lineCov","hits":"1","order":"810",},
{"lineNum":"  371","line":"        &self,"},
{"lineNum":"  372","line":"        path: P,"},
{"lineNum":"  373","line":"    ) -> io::Result<<Self::FileIter as File>::MD> {"},
{"lineNum":"  374","line":"        let fs = self.borrow();"},
{"lineNum":"  375","line":"        match fs.files.get(path.as_ref()) {"},
{"lineNum":"  376","line":"            Some(f) => f.get_metadata(),"},
{"lineNum":"  377","line":"            None => match fs.symlinks.get(path.as_ref()) {"},
{"lineNum":"  378","line":"                Some(&(ref f, _)) => f.get_metadata(),"},
{"lineNum":"  379","line":"                None => Err(io::Error::new(io::ErrorKind::NotFound, \"No such file\")),"},
{"lineNum":"  380","line":"            },"},
{"lineNum":"  381","line":"        }"},
{"lineNum":"  382","line":"    }"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"    /// VFS::read_link(p) resolves symlink at path p to the path its pointing to"},
{"lineNum":"  385","line":"    /// or gives an error if the link is broken."},
{"lineNum":"  386","line":"    fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf> {"},
{"lineNum":"  387","line":"        match self.borrow().symlinks.get(path.as_ref()) {"},
{"lineNum":"  388","line":"            Some(&(_, ref p)) => Ok(p.to_owned()),"},
{"lineNum":"  389","line":"            None => Err(io::Error::new(io::ErrorKind::NotFound, \"No such file\")),"},
{"lineNum":"  390","line":"        }"},
{"lineNum":"  391","line":"    }","class":"lineCov","hits":"1","order":"909",},
{"lineNum":"  392","line":"","class":"lineCov","hits":"1","order":"910",},
{"lineNum":"  393","line":"    fn get_file(&self, p: &Path) -> io::Result<Self::FileIter> {","class":"lineCov","hits":"1","order":"911",},
{"lineNum":"  394","line":"        match self.borrow().files.get(p) {","class":"lineNoCov","hits":"0",},
{"lineNum":"  395","line":"            Some(f) => Ok(f.to_owned()),"},
{"lineNum":"  396","line":"            None => Err(io::Error::new(io::ErrorKind::NotFound, \"No such file\")),","class":"lineCov","hits":"1","order":"912",},
{"lineNum":"  397","line":"        }"},
{"lineNum":"  398","line":"    }","class":"lineCov","hits":"1","order":"99",},
{"lineNum":"  399","line":"","class":"lineCov","hits":"1","order":"100",},
{"lineNum":"  400","line":"    fn rm_file<P: AsRef<Path>>(&mut self, p: &P) -> io::Result<()> {","class":"lineCov","hits":"1","order":"101",},
{"lineNum":"  401","line":"        let mut fs = self.borrow_mut();","class":"lineNoCov","hits":"0",},
{"lineNum":"  402","line":"        match fs.files.remove(p.as_ref()) {"},
{"lineNum":"  403","line":"            Some(_) => Ok(()),","class":"lineCov","hits":"1","order":"110",},
{"lineNum":"  404","line":"            None => Err(io::Error::new(io::ErrorKind::Other, \"Couldn\'t delete file\")),"},
{"lineNum":"  405","line":"        }","class":"lineCov","hits":"1","order":"259",},
{"lineNum":"  406","line":"    }","class":"lineCov","hits":"1","order":"260",},
{"lineNum":"  407","line":"","class":"lineCov","hits":"1","order":"261",},
{"lineNum":"  408","line":"    // create a hard link","class":"lineCov","hits":"1","order":"262",},
{"lineNum":"  409","line":"    fn make_link(&mut self, src: &Path, dst: &Path) -> io::Result<()> {","class":"lineNoCov","hits":"0",},
{"lineNum":"  410","line":"        let mut fs = self.borrow_mut();"},
{"lineNum":"  411","line":"        let old_md = fs.files","class":"lineCov","hits":"1","order":"263",},
{"lineNum":"  412","line":"            .get(dst)"},
{"lineNum":"  413","line":"            .ok_or_else(|| io::Error::new(io::ErrorKind::NotFound, \"No dst file\"))?"},
{"lineNum":"  414","line":"            .get_metadata()?;","class":"lineCov","hits":"1","order":"267",},
{"lineNum":"  415","line":"        // need to know the old inode so the new can have the same","class":"lineCov","hits":"1","order":"268",},
{"lineNum":"  416","line":"        let old_inode = old_md.get_inode();","class":"lineCov","hits":"1","order":"269",},
{"lineNum":"  417","line":"        let old_device = old_md.get_device()?;","class":"lineCov","hits":"1","order":"270",},
{"lineNum":"  418","line":"","class":"lineCov","hits":"1","order":"271",},
{"lineNum":"  419","line":"        // verify new file is going to be","class":"lineCov","hits":"1","order":"272",},
{"lineNum":"  420","line":"        let new_dir = src.parent().unwrap(); // can\'t be root"},
{"lineNum":"  421","line":"        let new_device = fs.files","class":"lineCov","hits":"1","order":"273",},
{"lineNum":"  422","line":"            .get(new_dir)","class":"lineCov","hits":"1","order":"277",},
{"lineNum":"  423","line":"            .ok_or_else(|| io::Error::new(io::ErrorKind::NotFound, \"No src md\"))?"},
{"lineNum":"  424","line":"            .get_metadata()?"},
{"lineNum":"  425","line":"            .get_device()?;","class":"lineCov","hits":"1","order":"278",},
{"lineNum":"  426","line":"","class":"lineCov","hits":"1","order":"279",},
{"lineNum":"  427","line":"        if old_device != new_device {","class":"lineCov","hits":"1","order":"280",},
{"lineNum":"  428","line":"            // can\'t make a hard link across devices (on most filesystems)","class":"lineCov","hits":"1","order":"281",},
{"lineNum":"  429","line":"            return Err(io::Error::new(","class":"lineCov","hits":"1","order":"282",},
{"lineNum":"  430","line":"                io::ErrorKind::Other,","class":"lineCov","hits":"1","order":"283",},
{"lineNum":"  431","line":"                \"Cannot make hard link across filesystems\","},
{"lineNum":"  432","line":"            ));","class":"lineCov","hits":"1","order":"284",},
{"lineNum":"  433","line":"        }"},
{"lineNum":"  434","line":"","class":"lineNoCov","hits":"0",},
{"lineNum":"  435","line":"        let name = src.to_str().expect(\"invalid unicode link name\");","class":"lineNoCov","hits":"0",},
{"lineNum":"  436","line":"        fs.files.insert("},
{"lineNum":"  437","line":"            src.to_path_buf(),"},
{"lineNum":"  438","line":"            TestFile::new(name).with_inode(old_inode.0),"},
{"lineNum":"  439","line":"        );"},
{"lineNum":"  440","line":"        Ok(())","class":"lineCov","hits":"1","order":"285",},
{"lineNum":"  441","line":"    }","class":"lineCov","hits":"1","order":"286",},
{"lineNum":"  442","line":"}","class":"lineCov","hits":"1","order":"287",},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "smllr-cd1387de2be9f35d", "date" : "2017-11-27 19:54:30", "instrumented" : 228, "covered" : 210,};
var merged_data = [];
